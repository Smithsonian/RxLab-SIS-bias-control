#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""Interactive script for controlling the 2SB system"""

import json
import time
import numpy as np
import matplotlib.pyplot as plt 
import socket
import uldaq

from appdirs import user_config_dir

from sisbias import SISBias, progress_bar, ask_filename, DAQNotFoundError
from labinstruments.microlambda import YigFilter
from labinstruments.hittite import Hittite

try:
    plt.style.use(["science", "sans", "no-latex"])
except ModuleNotFoundError:
    print("Matplotlib styles not found")
    print("\ttry: pip install SciencePlots")
except OSError:
    print("Matplot styles not found")
    print("\ttry: pip install SciencePlots")


def _read_if_power(_bias1, _bias2, average):
    """Read IF power from both channels at the same time (interleaved)."""
    pif_ch1, pif_ch2 = np.zeros(average), np.zeros(average)
    for j in range(average):
        pif_ch1[j] = _bias1.read_ifpower(average=1, offset_only=True)
        pif_ch2[j] = _bias2.read_ifpower(average=1, offset_only=True)
    return np.mean(pif_ch1), np.mean(pif_ch2)


# ----------------------------------------------------------------------------

daq_id1 = "01D87C3C"
daq_id2 = "01D87C1E"
config_filename1 = user_config_dir("2sb-mixer1.config")
config_filename2 = user_config_dir("2sb-mixer2.config")
param_filename1 = user_config_dir("2sb-mixer1.param")
param_filename2 = user_config_dir("2sb-mixer2.param")
cal_filename1 = user_config_dir("2sb-mixer1.cal")
cal_filename2 = user_config_dir("2sb-mixer2.cal")

# filteraddr = "192.168.1.15"
# filteraddr = args.filteraddr

with open(param_filename1) as _fin:
    param1 = json.load(_fin)

with open(param_filename2) as _fin:
    param2 = json.load(_fin)

# ----------------------------------------------------------------------------

bias1, bias2 = None, None
if_filter1, if_filter2 = None, None
tone_synth = None

try:

    # Initialize bias control (connect to DAQ devices)
    bias1 = SISBias(config_file=config_filename1, cal_file=cal_filename1, daq_id=daq_id1, name="Channel 1")
    bias2 = SISBias(config_file=config_filename2, cal_file=cal_filename2, daq_id=daq_id2, name="Channel 2")
    
    # Set bias voltage to previous value
    bias1.set_control_voltage(param1['VCTRL'], verbose=True)
    bias2.set_control_voltage(param2['VCTRL'], verbose=True)
    print("")

    # Save voltage / current gain to param (from config file)
    param1["VMONGAIN"] = bias1.config['VMON']['GAIN']
    param2["VMONGAIN"] = bias2.config['VMON']['GAIN']
    param1["IMONGAIN"] = bias1.config['IMON']['GAIN']
    param2["IMONGAIN"] = bias2.config['IMON']['GAIN']
    param1["VMONOFFSET"] = bias1.config['VMON']['OFFSET']
    param2["VMONOFFSET"] = bias2.config['VMON']['OFFSET']
    param1["IMONOFFSET"] = bias1.config['IMON']['OFFSET']
    param2["IMONOFFSET"] = bias2.config['IMON']['OFFSET']

    # Connect to IF filters and set to previous frequency
    print("Connecting to IF filter 1...")
    try:
        if_filter1 = YigFilter("192.168.1.12", f_adjust=0.000)
    except socket.timeout:
        print("Unable to connect to IF filter #1")
        if_filter1 = None
    print("Connecting to IF filter 2...")
    try:
        if_filter2 = YigFilter("192.168.1.15", f_adjust=0.000)
    except socket.timeout:
        print("Unable to connect to IF filter #1")
        if_filter2 = None
    time.sleep(1)  # TODO: is this needed?
    if if_filter1:
        if_filter1.set_frequency(param1['IFFREQ'])
    if if_filter2:
        if_filter2.set_frequency(param1['IFFREQ'])

    # Connect to synthesizer for tone injection
    print("Connecting to frequency synthesizer...")
    try:
        tone_synth = Hittite("192.168.1.31", timeout=1, f_adjust=0.000)
    except:
        pass

    print("\nRemember to specify measurement parameters:")
    print("\t-> device, njunc, icoil, freq")

    # For interactive plots
    plt.ion()

    # Loop continuously for interactive environment
    while True:

        # Get next command
        command = input(">> ")
        command = command.split()
        if len(command) == 0:
            continue
        if not isinstance(command, list):
            command = [command, ]
        command[0] = command[0].upper()

        # Set parameters --------------------------------------------------- #

        skip_commands = ["F", "IF", "V1", "V2", "VB1", "VB2"]
        device_specific = ["DEVICE", "NJUNC", "ICOIL"]

        # PARAMETERS: CHANNEL 1
        if command[0][-1:] == "1" and command[0][:-1] in param1.keys() and command[0][:-1] not in skip_commands and command[0] not in skip_commands:

            # Print parameter value
            if len(command) == 1:
                print(f"\n\t{command[0][:-1]} : {param1[command[0][:-1]]}\n")
            # Set parameter value
            elif len(command) == 2:
                # String parameters
                if command[0][:-1].upper() in ["LNA", "DEVICE"]:
                    param1[command[0][:-1].upper()] = command[1]
                # Float parameters
                else:
                    try:
                        param1[command[0][:-1]] = float(command[1])
                    except ValueError:
                        print("\n\tError: Value must be int or float.\n")
            # Error
            else:
                print("\n\tError too many values provided for parameter.")

        # PARAMETERS: CHANNEL 2
        elif command[0][-1:] == "2" and command[0][:-1] in param2.keys() and command[0][:-1] not in skip_commands and command[0] not in skip_commands:

            # Print parameter value
            if len(command) == 1:
                print(f"\n\t{command[0][:-1]} : {param2[command[0][:-1]]}\n")
            # Set parameter value
            elif len(command) == 2:
                # String parameters
                if command[0][:-1].upper() in ["LNA", "DEVICE"]:
                    param2[command[0][:-1].upper()] = command[1]
                # Float parameters
                else:
                    try:
                        param2[command[0][:-1]] = float(command[1])
                    except ValueError:
                        print("\n\tError: Value must be int or float.\n")
            # Error
            else:
                print("\n\tError too many values provided for parameter.")

        # PARAMETERS: BOTH CHANNELS
        elif command[0] in param1.keys() and command[0] not in skip_commands and command[0] not in device_specific:

            # Print parameter value
            if len(command) == 1:
                print(f"\n\t{command[0]} : {param1[command[0]]}\n")
            # Set parameter value
            elif len(command) == 2:
                # String parameters
                if command[0].upper() in ["LNA", "DEVICE"]:
                    param1[command[0].upper()] = command[1]
                    param2[command[0].upper()] = command[1]
                # Float parameters
                else:
                    try:
                        param1[command[0]] = float(command[1])
                        param2[command[0]] = float(command[1])
                    except ValueError:
                        print("\n\tError: Value must be int or float.\n")
            # Error
            else:
                print("\n\tError too many values provided for parameter.")

        # F: Record LO frequency (no action)
        elif command[0] == "F":

            # Print help
            if len(command) == 2 and command[1].upper() == "H":
                print("\n\tSet LO frequency parameter (no action)\n")
                print("\tUsage: F <freq>")
                print("\twhere <freq> is the frequency in units [GHz]\n")
                continue

            if len(command) > 1:
                try:
                    param1['FREQ'] = float(command[1])
                    param2['FREQ'] = float(command[1])
                    if param1['FREQ'] != 0:
                        print("")
                        _f_lo = param1['FREQ']
                        _f_pll = (_f_lo / 3 -  0.1) * 1e3
                        print(f"\tLO frequency:     {_f_lo:10.6f} GHz\n")
                        print(f"\tSource frequency: {_f_lo/18:10.6f} GHz (x18)")
                        print(f"\t                  {_f_lo/9:10.6f} GHz (x9)")
                        print(f"\t                  {_f_lo/3:10.6f} GHz (x3)\n")
                        print(f"\tPLL frequency:  {_f_pll/8:12.6f} MHz (n=8)")
                        print(f"\t                {_f_pll/10:12.6f} MHz (n=10)")
                        print(f"\t                {_f_pll/12:12.6f} MHz (n=12)")
                        print("")
                    else:
                        print("\n\tDC (no LO pumping)\n")
                except ValueError:
                    print("\n\tError: Frequency must be a float.\n")
            else:
                print(f"\n\tLO frequency: {param1['FREQ']:.1f} GHz\n")

        # IF: Set IF frequency
        elif command[0] == "IF":

            # Print help
            if len(command) == 2 and command[1].upper() == "H":
                print("\n\tSet IF frequency\n")
                print("\tUsage: IF <freq>")
                print("\twhere <freq> is the frequency in units [GHz]\n")
                continue

            if len(command) > 1:
                try:
                    if_freq = float(command[1])
                    param1['IFFREQ'] = if_freq
                    param2['IFFREQ'] = if_freq
                    if_filter1.set_frequency(if_freq)
                    if_filter2.set_frequency(if_freq)
                except ValueError:
                    print("\n\tError: Frequency must be a float.\n")
            else:
                print(f"\n\tIF frequency: {param1['IFFREQ']:.3f}\n")

        # VB1: Set bias voltage (constant)
        elif command[0] == "VB1":

            # Print help
            if len(command) == 2 and command[1].upper() == "H":
                print("\n\tSet bias voltage for channel 1\n")
                print("\tUsage: VB1 <vbias> <iterations>")
                print("\twhere <vbias> is the voltage in units [mV] (default 0)")
                print("\t      <iterations> is the number of iterations (default 3)\n")
                continue

            # arg 1: target value
            # TODO: fix to use len(command) instead of try/except
            try: 
                vbias = float(command[1])
            except (IndexError, ValueError) as e:
                vbias = None

            # arg 2: number of iterations
            try:
                iterations = int(command[2])
            except (IndexError, ValueError) as e:
                iterations = 1
            
            if vbias is not None:
                print(f"\n\tBias target:   {vbias:6.2f} mV\n")
                _, param1['VCTRL'] = bias1.set_bias_voltage(vbias, iterations=iterations, verbose=True, vlimit=param1["VLIMIT"])
            else:
                _ = bias1.read_voltage(average=64, verbose=True)

        # VB2: Set bias voltage (constant)
        elif command[0] == "VB2":

            # Print help
            if len(command) == 2 and command[1].upper() == "H":
                print("\n\tSet bias voltage for channel 2\n")
                print("\tUsage: VBIAS2 <vbias> <iterations>")
                print("\t        VB2 <vbias> <iterations>")
                print("\twhere <vbias> is the voltage in units [mV] (default 0)")
                print("\t      <iterations> is the number of iterations (default 3)\n")
                continue

            # arg 1: target value
            try: 
                vbias = float(command[1])
            except (IndexError, ValueError) as e:
                vbias = None

            # arg 2: number of iterations
            try:
                iterations = int(command[2])
            except (IndexError, ValueError) as e:
                iterations = 1
            
            if vbias is not None:
                print(f"\n\tBias target:   {vbias:6.2f} mV\n")
                _, param2['VCTRL'] = bias2.set_bias_voltage(vbias, iterations=iterations, verbose=True, vlimit=param2["VLIMIT"])
            else:
                _ = bias2.read_voltage(average=64, verbose=True)

        # VBMIN: Set minimum bias voltage for voltage sweep
        elif command[0] == "VBMIN":

            # Print help
            if len(command) == 2 and command[1].upper() == "H":
                print("\n\tSet minimum bias voltage (both channels)\n")
                print("\tUsage: VBMIN <vbias>")
                print("\twhere <vbias> is the voltage in units [mV] (default 0)\n")
                continue

            # arg 1: target value
            try: 
                vbias = float(command[1])
                param1['VMIN'] = bias1.bias_to_control_voltage(vbias)
                param2['VMIN'] = bias2.bias_to_control_voltage(vbias)
            except (IndexError, ValueError) as e:
                vbias = bias1.control_to_bias_voltage(param1['VMIN'])
                # vbias = bias2.control_to_bias_voltage(param2['VMIN'])

            print(f"\n\tBias voltage (min):    {vbias:.1f} mV")
            print(f"  \tControl voltage (min): {param1['VMIN']:.1f} V\n")

        # VBMAX: Set maximum bias voltage for voltage sweep
        elif command[0] == "VBMAX":

            # Print help
            if len(command) == 2 and command[1].upper() == "H":
                print("\n\tSet maximum bias voltage (both channels)\n")
                print("\tUsage: VBMAX <vbias>")
                print("\twhere <vbias> is the voltage in units [mV] (default 0)\n")
                continue

            # arg 1: target value
            try: 
                vbias = float(command[1])
                param1['VMAX'] = bias1.bias_to_control_voltage(vbias)
                param2['VMAX'] = bias2.bias_to_control_voltage(vbias)
            except (IndexError, ValueError) as e:
                vbias = bias1.control_to_bias_voltage(param1['VMAX'])
                # vbias = bias2.control_to_bias_voltage(param2['VMAX'])

            print(f"\n\tBias voltage (max):    {vbias:.1f} mV")
            print(f"  \tControl voltage (max): {param1['VMAX']:.1f} V\n")

        # Calibration ------------------------------------------------------ #

        # CALIF: Calibrate IF power (channel 1)
        elif command[0] == "CALIF":

            # Print help
            if len(command) == 2 and command[1].upper() == "H":
                print("\n\tCalibrate IF power (both channels)\n")
                print("\tUsage: CALIF <shot>")
                print("\twhere <shot> calibrate IF power using shot noise slope? 1 yes, 0 no (default)\n")
                continue

            print("\n\tCALIBRATE IF POWER (BOTH CHANNELS)")

            # arg 1: calibrate IF power using shot noise slope
            if len(command) > 1:
                shot = int(command[1])
            else:
                shot = 0
            shot ==  1

            vbmin = param1['VBMIN_LINEAR']
            vbmax = param1['VBMAX_LINEAR']
            average = 10_000

            # Make sure voltage sweeps are stationary
            bias1.set_control_voltage(param1['VCTRL'])
            bias2.set_control_voltage(param2['VCTRL'])

            # Calculate IF power offset
            print("\n\tCHANNEL 1:")
            param1["IFOFFSET"] = bias1.calibrate_if_offset(average=average, wait2=False)
            bias1.set_control_voltage(param1['VCTRL'])
            print("\tCHANNEL 2:")
            param2["IFOFFSET"] = bias2.calibrate_if_offset(average=average, wait1=False)
            bias2.set_control_voltage(param2['VCTRL'])

            # Calculate shot noise slope
            if shot:
                print("\n\tCalibrating IF power (using shot noise):\n")
                print(f"\tBias voltage sweep: {vbmin:.1f} to {vbmax:.1f} mV\n")
                vmin = vbmin / 1000 * bias1.config['VMON']['GAIN'] 
                vmax = vbmax / 1000 * bias1.config['VMON']['GAIN'] 
                param1["IFCORR"], param2["IFCORR"] = bias1.calibrate_if(vmin=vmin, vmax=vmax, average=average, njunc=param1["NJUNC"], extra=False, debug=True, bias2=bias2)
                bias1.set_control_voltage(param1['VCTRL'])
                bias2.set_control_voltage(param2['VCTRL'])

        # CALIV: Calibrate I-V data
        elif command[0] == "CALIV":

            # Print help
            if len(command) == 2 and command[1].upper() == "H":
                print("\n\tCalibrate I-V offset (both channels)\n")
                print("\tUsage: CALIV\n")
                continue

            print("\n\tCALIBRATE I-V OFFSET (BOTH CHANNELS)\n")
            
            print("\tCHANNEL 1:\n")
            param1["IOFFSET"], param1["VOFFSET"] = bias1.calibrate_iv_offset(debug=True)
            bias1.set_control_voltage(param1['VCTRL'])
            print("\tCHANNEL 2:\n")
            param2["IOFFSET"], param2["VOFFSET"] = bias2.calibrate_iv_offset(debug=True)
            bias2.set_control_voltage(param2['VCTRL'])

        # Read out single values (no sweep) -------------------------------- #

        # VMON: Read voltage monitor
        elif command[0] == "VMON":

            # Print help
            if len(command) == 2 and command[1].upper() == "H":
                print("\n\tMeasure voltage monitor (both channels)\n")
                print("\tUsage: VMON <average>")
                print("\twhere <average> is the number of points to average (default is 2000)\n")
                continue

            # arg 1: number of points to average
            try:
                average = int(command[1])
            except (IndexError, ValueError) as e:
                average = 2_000

            _ = bias1.read_voltage(average=average, verbose=True, msg="\n\tVoltage monitor (channel 1)")
            _ = bias2.read_voltage(average=average, verbose=True, msg="\tVoltage monitor (channel 2)")

        # IMON: Read current monitor
        elif command[0] == "IMON":

            # Print help
            if len(command) == 2 and command[1].upper() == "H":
                print("\n\tMeasure current monitor (both channels)\n")
                print("\tUsage: IMON <average>")
                print("\twhere <average> is the number of points to average (default is 2000)\n")
                continue

            # arg 1: number of points to average
            try:
                average = int(command[1])
            except (IndexError, ValueError) as e:
                average = 2_000

            _ = bias1.read_current(average=average, verbose=True, msg="\n\tCurrent monitor (channel 1)")
            _ = bias2.read_current(average=average, verbose=True, msg="\tCurrent monitor (channel 2)")

        # PIF: Read IF power
        elif command[0] == "PIF":

            # Print help
            if len(command) == 2 and command[1].upper() == "H":
                print("\n\tMeasure IF power of both channels\n")
                print("\tUsage: PIF <average>")
                print("\twhere <average> is the number of points to average (default is 2000)\n")
                continue

            # arg 1: number of points to average
            try:
                average = int(command[1])
            except (IndexError, ValueError) as e:
                average = 2_000

            _ = bias1.read_ifpower(average=average, verbose=True, msg="\n\tIF power (channel 1)")
            _ = bias2.read_ifpower(average=average, verbose=True, msg="\tIF power (channel 2)")

        # Measure IV / IF data --------------------------------------------- #

        # MONITOR: Real time plot of I-V curve
        elif command[0] == "MON":

            # Print help
            if len(command) == 2 and command[1].upper() == "H":
                print("\n\tPlot I-V/IF data in real-time (both channels)\n")
                print("\tUsage: MONITOR <resistance>")
                print("\t        MON <resistance>")
                print("\twhere <resistance> will plot a resistance line for reference\n")
                continue

            print("\n\tMONITOR (BOTH CHANNELS):")

            if len(command) > 1:
                resistance = float(command[1])
            else:
                resistance = None

            # Start I-V bias sweeps
            bias1.sweep_control_voltage(param1['VMIN'], param1['VMAX'], npts=param1['NPTS'], sweep_period=param1['PERIOD'], vlimit=param1['VLIMIT'])
            bias2.sweep_control_voltage(param2['VMIN'], param2['VMAX'], npts=param2['NPTS'], sweep_period=param2['PERIOD'], vlimit=param2['VLIMIT'])
            bias1.start_iv_monitor_scan(npts=param1['NPTS'], sweep_period=param1['PERIOD'])
            bias2.start_iv_monitor_scan(npts=param2['NPTS'], sweep_period=param2['PERIOD'])
            time.sleep(param1['PERIOD'] * 2)
            print("")

            # Read I-V curve
            voltage1, current1, ifpower1 = bias1.read_iv_curve_buffer()
            voltage2, current2, ifpower2 = bias2.read_iv_curve_buffer()

            # Create figure
            plt.ion()
            fig, ax1 = plt.subplots(figsize=(6, 5))
            ax1.set_xlabel("Voltage (mV)")
            ax1.set_ylabel("Current (uA)")
            ax1.set_xlim([voltage1.min(), voltage1.max()])
            if resistance is None:
                ax1.set_ylim([current1.min(), current1.max()])
            else:
                irmin = voltage1.min() / resistance * 1e3
                irmax = voltage1.max() / resistance * 1e3
                ax1.set_ylim([irmin, irmax])
                line0, = ax1.plot([voltage1.min(), voltage1.max()], [irmin, irmax], 'r', label=f"{resistance:.0f} ohms")
            line1, = ax1.plot([0], [0], 'b.', ms=1, label="Channel 1")
            line2, = ax1.plot([0], [0], 'r.', ms=1, label="Channel 2")
            ax1.legend() 
            fig.canvas.draw()
            plt.show()

            while True:
                try:
                    # Restart scans
                    bias1.sweep_control_voltage(param1['VMIN'], param1['VMAX'], npts=param1['NPTS'], sweep_period=param1['PERIOD'], vlimit=param1['VLIMIT'], verbose=False)
                    bias2.sweep_control_voltage(param2['VMIN'], param2['VMAX'], npts=param2['NPTS'], sweep_period=param2['PERIOD'], vlimit=param2['VLIMIT'], verbose=False)
                    bias1.start_iv_monitor_scan(npts=param1['NPTS'], sweep_period=param1['PERIOD'], verbose=False)
                    bias2.start_iv_monitor_scan(npts=param2['NPTS'], sweep_period=param2['PERIOD'], verbose=False)
                    time.sleep(param1['PERIOD'])

                    # Read I-V curve
                    voltage1, current1, ifpower1 = bias1.read_iv_curve_buffer()
                    voltage2, current2, ifpower2 = bias2.read_iv_curve_buffer()

                    # Draw I-V curve
                    line1.set_data(voltage1, current1)
                    line2.set_data(voltage2, current2)
                    fig.canvas.draw()
                    plt.pause(0.0001)
                    fig.canvas.flush_events()

                except KeyboardInterrupt:
                    plt.close('all')
                    bias1.set_control_voltage(param1['VCTRL'], vlimit=param1['VLIMIT'])
                    bias2.set_control_voltage(param2['VCTRL'], vlimit=param2['VLIMIT'])
                    print(f"\n\tControl voltage (channel 1) returned to {param1['VCTRL']:.2f} V.")
                    print(f"\n\tControl voltage (channel 2) returned to {param2['VCTRL']:.2f} V.\n")
                    break

        # MONITOR1: Real time plot of I-V curve
        elif command[0] == "MON1":

            # Print help
            if len(command) == 2 and command[1].upper() == "H":
                print("\n\tPlot I-V/IF data in real-time (channel 1)\n")
                print("\tUsage: MONITOR1 <resistance>")
                print("\t        MON1 <resistance>")
                print("\twhere <resistance> will plot a resistance line for reference\n")
                continue

            print("\n\tMONITOR (CHANNEL 1):")

            if len(command) > 1:
                resistance = float(command[1])
            else:
                resistance = None

            bias1.monitor(npts=param1['NPTS'], period=param1['PERIOD'], vmin=param1['VMIN'], vmax=param1['VMAX'], vlimit=param1['VLIMIT'], resistance=resistance, vctrl=param1['VCTRL'])

        # MONITOR2: Real time plot of I-V curve
        elif command[0] == "MON2":

            # Print help
            if len(command) == 2 and command[1].upper() == "H":
                print("\n\tPlot I-V/IF data in real-time (channel 2)\n")
                print("\tUsage: MONITOR2 <resistance>")
                print("\t        MON2 <resistance>")
                print("\twhere <resistance> will plot a resistance line for reference\n")
                continue

            print("\n\tMONITOR (CHANNEL 2):")

            if len(command) > 1:
                resistance = float(command[1])
            else:
                resistance = None

            bias2.monitor(npts=param2['NPTS'], period=param2['PERIOD'], vmin=param2['VMIN'], vmax=param2['VMAX'], vlimit=param2['VLIMIT'], resistance=resistance, vctrl=param2['VCTRL'])

        # MEASURE: Measure IV / IF curve
        elif command[0] == "M":

            # Print help
            if len(command) == 2 and command[1].upper() == "H":
                print("\n\tMeasure I-V/IF curves (both channels)\n")
                print("\tUsage: MEASURE <npts> <average> <sleeptime>")
                print("\t        M <npts> <average> <sleeptime>")
                print("\twhere <npts> is the number of points (default 1001)")
                print("\t      <average> is the averaging (default 64)")
                print("\t      <sleeptime> is the sleep time between points (default 0.1)\n")
                continue

            print("\n\tMEASURE I-V + IF CURVE (BOTH CHANNELS):")

            # arg 1: number of points
            if len(command) > 1:
                npts = int(command[1])
            else:
                npts = 1001

            # arg 2: averaging
            if len(command) > 2:
                average = int(command[2])
            else:
                average = 64

            # arg 3: sleep time
            if len(command) > 3:
                sleep_time = float(command[3])
            else:
                sleep_time = 0.1

            # Parameters
            vmin, vmax = param1["VMIN"], param1["VMAX"]
            vbmin = vmin * 1000 / bias1.config['VMON']['GAIN']
            vbmax = vmax * 1000 / bias1.config['VMON']['GAIN']
            vctrl_sweep = np.linspace(vmin, vmax, npts)
            print(f"\n\tControl voltage sweep: {vmin:5.1f} to {vmax:5.1f} V")
            print(f"  \tBias voltage sweep:    {vbmin:5.1f} to {vbmax:5.1f} mV\n")

            # Sweep bias voltage and measure voltage / current / IF power
            try:
                voltage1, voltage2 = np.zeros(npts), np.zeros(npts)
                current1, current2 = np.zeros(npts), np.zeros(npts)
                ifpower1, ifpower2 = np.zeros(npts), np.zeros(npts)
                for i, _vctrl in np.ndenumerate(vctrl_sweep):
                    bias1.set_control_voltage(_vctrl, vlimit=param1['VLIMIT'])
                    bias2.set_control_voltage(_vctrl, vlimit=param2['VLIMIT'])
                    time.sleep(sleep_time)
                    voltage1[i], current1[i], ifpower1[i] = bias1.read_all(average=average)
                    voltage2[i], current2[i], ifpower2[i] = bias2.read_all(average=average)
                    progress_bar(i[0] + 1, len(vctrl_sweep), prefix="\tProgress: ")
            except KeyboardInterrupt:
                print("")
                plt.close('all')
                continue
            bias1.set_control_voltage(param1['VCTRL'])
            bias2.set_control_voltage(param2['VCTRL'])

            # Sort by voltage
            idx = voltage1.argsort()
            voltage1, current1, ifpower1 = voltage1[idx], current1[idx], ifpower1[idx]
            idx = voltage2.argsort()
            voltage2, current2, ifpower2 = voltage2[idx], current2[idx], ifpower2[idx]

            # Find intercept, normal resistance and IF noise
            print(f"\n\tRange for linear fit:\t{param1['VBMIN_LINEAR']:5.1f} to {param1['VBMAX_LINEAR']:5.1f} mV")
            if param1['FREQ'] == 0:
                mask1 = (param1['VBMIN_LINEAR'] <= voltage1) & (voltage1 <= param1['VBMAX_LINEAR'])
                mask2 = (param2['VBMIN_LINEAR'] <= voltage2) & (voltage2 <= param2['VBMAX_LINEAR'])
                try:
                    pnormal1 = np.polyfit(voltage1[mask1], current1[mask1], 1)
                    pnormal2 = np.polyfit(voltage2[mask2], current2[mask2], 1)
                    v_intercept1 = -pnormal1[1] / pnormal1[0]
                    v_intercept2 = -pnormal2[1] / pnormal2[0]
                    print(f"\n\tIntercept:\t\t{v_intercept1:.3f} mV (channel 1)")
                    print(f"\n\tIntercept:\t\t{v_intercept2:.3f} mV (channel 2)")
                    rnormal1 = 1000 / pnormal1[0]
                    rnormal2 = 1000 / pnormal2[0]
                    print(f"  \tNormal resistance:\t{rnormal1:.1f} ohms (channel 1)")
                    print(f"  \tNormal resistance:\t{rnormal2:.1f} ohms (channel 2)")
                    pifnoise1 = np.polyfit(voltage1[mask1], ifpower1[mask1], 1)
                    pifnoise2 = np.polyfit(voltage2[mask2], ifpower2[mask2], 1)
                    if_noise1 = np.polyval(pifnoise1, v_intercept1)
                    if_noise2 = np.polyval(pifnoise2, v_intercept2)
                    gamma1 = (50 - rnormal1) / (50 + rnormal1)
                    gamma2 = (50 - rnormal2) / (50 + rnormal2)
                    gmismatch1 = 1 - np.abs(gamma1) ** 2
                    gmismatch2 = 1 - np.abs(gamma2) ** 2
                    if_noise_corr1 = (if_noise1 - 1.3) * gmismatch1
                    if_noise_corr2 = (if_noise2 - 1.3) * gmismatch2
                    print(f"  \tIF noise:\t\t{if_noise1:.1f} K (channel 1)")
                    print(f"  \tIF noise:\t\t{if_noise2:.1f} K (channel 2)")
                    print(f"  \tIF noise:\t\t{if_noise_corr1:.1f} K after correction (channel 1)")
                    print(f"  \tIF noise:\t\t{if_noise_corr2:.1f} K after correction (channel 2)")
                    print(f"  \tMean IF power:\t\t{np.mean(ifpower1):.1f} K (channel 1)")
                    print(f"  \tMean IF power:\t\t{np.mean(ifpower2):.1f} K (channel 2)\n")
                except:
                    pnormal1 = None
                    pnormal2 = None
                    pifnoise1 = None
                    pifnoise2 = None
                    v_intercept1 = None 
                    v_intercept2 = None 
                    rnormal1 = None 
                    rnormal2 = None 
                    if_noise1 = None
                    if_noise2 = None
                    if_noise_corr1 = None
                    if_noise_corr2 = None
                    pass

            # Plot I-V curve
            fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5))
            ax1.plot(voltage1, current1, 'b-', label='I-V curve (ch. 1)')
            ax1.plot(voltage2, current2, 'r-', label='I-V curve (ch. 2)')
            if vmin == -vmax:
                ax1.plot(-voltage1, -current1, 'b-', alpha=0.5)
                ax1.plot(-voltage2, -current2, 'r-', alpha=0.5)
            if param1['FREQ'] == 0:
                if pnormal1 is not None and pnormal2 is not None:
                    ax1.plot(voltage1[voltage1 > 0], np.polyval(pnormal1, voltage1[voltage1 > 0]), 'b-', lw=0.5, label=r"$R_n={:.1f}~\Omega$ (ch. 1)".format(rnormal1))
                    ax1.plot(voltage2[voltage2 > 0], np.polyval(pnormal2, voltage2[voltage2 > 0]), 'r-', lw=0.5, label=r"$R_n={:.1f}~\Omega$ (ch. 2)".format(rnormal2))
                if v_intercept1 is not None and v_intercept2 is not None:
                    ax1.plot(v_intercept1, 0, 'b*', ms=10, label="$x$-intercept (ch. 1)")
                    ax1.plot(v_intercept2, 0, 'r*', ms=10, label="$x$-intercept (ch. 2)")
            ax1.set_xlabel("Voltage (mV)")
            ax1.set_ylabel("Current (uA)")
            ax1.legend(loc=2, frameon=True)

            # Plot IF power
            ax2.plot(voltage1, ifpower1, 'b-', label='IF power (ch. 1)')
            ax2.plot(voltage2, ifpower2, 'r-', label='IF power (ch. 2)')
            if vmin == -vmax:
                ax2.plot(-voltage1, ifpower1, 'b-', alpha=0.5)
                ax2.plot(-voltage2, ifpower2, 'r-', alpha=0.5)
            if param1['FREQ'] == 0:
                if pifnoise1 is not None:
                    ax2.plot(voltage1, np.polyval(pifnoise1, voltage1), 'b-', lw=0.5)
                    ax2.plot(voltage2, np.polyval(pifnoise2, voltage2), 'r-', lw=0.5)
                    tif_str = r"$T_\mathrm{IF}$"
                if v_intercept1 is not None and if_noise1 is not None:
                    ax2.plot(v_intercept1, if_noise1, 'b^', ms=10, label="{}: {:.1f} K".format(tif_str, if_noise1))
                    ax2.plot(v_intercept2, if_noise2, 'r^', ms=10, label="{}: {:.1f} K".format(tif_str, if_noise2))
                    tif_str = r"$T_\mathrm{IF}^\prime$"
                if if_noise_corr1 is not None:
                    ax2.plot(v_intercept1, if_noise_corr1, 'bv', ms=10, label="{}: {:.1f} K".format(tif_str, if_noise_corr1))
                    ax2.plot(v_intercept2, if_noise_corr2, 'rv', ms=10, label="{}: {:.1f} K".format(tif_str, if_noise_corr2))
            ax2.legend(loc=4, frameon=True)
            ax2.set_ylabel("IF Power (K)")
            ax2.set_xlabel("Voltage (mV)")
            ax2.set_ylim(ymin=0)
            plt.show()

            filename1 = ask_filename(msg="\tFile name (channel 1): ")
            filename2 = ask_filename(msg="\tFile name (channel 2): ")
            if filename1 is None:
                print("\n\tNot saving any data for channel 1.\n")
            else:
                # Save data
                header = "Voltage (mV), Current (uA), IF power (K)"
                np.savetxt(filename1 + ".dat", np.vstack((voltage1, current1, ifpower1)).T, header=header)
                # Save metadata
                with open(filename1 + ".mdat", "w") as fout:
                    json.dump(param1, fout, indent=4)
            if filename2 is None:
                print("\n\tNot saving any data for channel 2.\n")
            else:
                # Save data
                header = "Voltage (mV), Current (uA), IF power (K)"
                np.savetxt(filename2 + ".dat", np.vstack((voltage2, current2, ifpower2)).T, header=header)
                # Save metadata
                with open(filename2 + ".mdat", "w") as fout:
                    json.dump(param2, fout, indent=4)

        # MEASURE1: Measure IV / IF curve
        elif command[0] == "M1":

            # Print help
            if len(command) == 2 and command[1].upper() == "H":
                print("\n\tMeasure I-V/IF curves (channel 1)\n")
                print("\tUsage: MEASURE1 <npts> <average> <sleeptime>")
                print("\t        M1 <npts> <average> <sleeptime>")
                print("\twhere <npts> is the number of points (default 1001)")
                print("\t      <average> is the averaging (default 64)")
                print("\t      <sleeptime> is the sleep time between points (default 0.1)\n")
                continue

            print("\n\tMEASURE I-V + IF CURVE (CHANNEL 1):")

            # arg 1: number of points
            if len(command) > 1:
                npts = int(command[1])
            else:
                npts = 1001

            # arg 2: averaging
            if len(command) > 2:
                average = int(command[2])
            else:
                average = 64

            # arg 3: sleep time
            if len(command) > 3:
                sleep_time = float(command[3])
            else:
                sleep_time = 0.1

            # Parameters
            vmin, vmax = param1["VMIN"], param1["VMAX"]
            vbmin = vmin * 1000 / bias1.config['VMON']['GAIN']
            vbmax = vmax * 1000 / bias1.config['VMON']['GAIN']
            vctrl_sweep = np.linspace(vmin, vmax, npts)
            print(f"\n\tControl voltage sweep: {vmin:5.1f} to {vmax:5.1f} V")
            print(f"  \tBias voltage sweep:    {vbmin:5.1f} to {vbmax:5.1f} mV\n")

            # Sweep bias voltage and measure voltage / current / IF power
            try:
                voltage = np.zeros(npts)
                current = np.zeros(npts)
                ifpower = np.zeros(npts)
                for i, _vctrl in np.ndenumerate(vctrl_sweep):
                    bias1.set_control_voltage(_vctrl, vlimit=param1['VLIMIT'])
                    time.sleep(sleep_time)
                    voltage[i], current[i], ifpower[i] = bias1.read_all(average=average)
                    progress_bar(i[0] + 1, len(vctrl_sweep), prefix="\tProgress: ")
            except KeyboardInterrupt:
                print("")
                plt.close('all')
                bias1.set_control_voltage(param1['VCTRL'], vlimit=param1['VLIMIT'])
                print(f"\n\tControl voltage (channel 1) returned to {param1['VCTRL']:.2f} V.\n")
                continue
            bias1.set_control_voltage(param1['VCTRL'])

            # Sort by voltage
            idx = voltage.argsort()
            voltage, current, ifpower = voltage[idx], current[idx], ifpower[idx]

            # Find intercept, normal resistance and IF noise
            print(f"\n\tRange for linear fit:\t{param1['VBMIN_LINEAR']:5.1f} to {param1['VBMAX_LINEAR']:5.1f} mV")
            if param1['FREQ'] == 0:
                mask = (param1['VBMIN_LINEAR'] <= voltage) & (voltage <= param1['VBMAX_LINEAR'])
                try:
                    pnormal = np.polyfit(voltage[mask], current[mask], 1)
                    v_intercept = -pnormal[1] / pnormal[0]
                    print(f"\n\tIntercept:\t\t{v_intercept:.3f} mV")
                    rnormal = 1000 / pnormal[0]
                    print(f"  \tNormal resistance:\t{rnormal:.1f} ohms")
                    pifnoise = np.polyfit(voltage[mask], ifpower[mask], 1)
                    if_noise = np.polyval(pifnoise, v_intercept)
                    gamma = (50 - rnormal) / (50 + rnormal)
                    gmismatch = 1 - np.abs(gamma) ** 2
                    if_noise_corr = (if_noise - 1.3) * gmismatch
                    print(f"  \tIF noise:\t\t{if_noise:.1f} K")
                    print(f"  \t         \t\t{if_noise_corr:.1f} K (after correction)")
                    print(f"  \tMean IF power:\t\t{np.mean(ifpower):.1f} K\n")
                except:
                    pnormal = None
                    pifnoise = None
                    v_intercept = None 
                    rnormal = None 
                    if_noise = None
                    if_noise_corr = None
                    pass

            # Plot I-V curve
            fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5))
            ax1.plot(voltage, current, 'k-', label='I-V curve')
            if vmin == -vmax:
                ax1.plot(-voltage, -current, 'k-', alpha=0.5)
            if param1['FREQ'] == 0:
                if pnormal is not None:
                    ax1.plot(voltage[voltage > 0], np.polyval(pnormal, voltage[voltage > 0]), 'r-', lw=0.5, label=r"$R_n={:.1f}~\Omega$".format(rnormal))
                if v_intercept is not None:
                    ax1.plot(v_intercept, 0, 'r*', ms=10, label="$x$-intercept")
            ax1.set_xlabel("Voltage (mV)")
            ax1.set_ylabel("Current (uA)")
            ax1.legend(loc=2, frameon=True)

            # Plot IF power
            ax2.plot(voltage, ifpower, 'k-', label='IF power')
            if vmin == -vmax:
                ax2.plot(-voltage, ifpower, 'k-', alpha=0.5)
            if param1['FREQ'] == 0:
                if pifnoise is not None:
                    ax2.plot(voltage, np.polyval(pifnoise, voltage), 'r-', lw=0.5)
                    tif_str = r"$T_\mathrm{IF}$"
                if v_intercept is not None and if_noise is not None:
                    ax2.plot(v_intercept, if_noise, 'r*', ms=10, label="{}: {:.1f} K".format(tif_str, if_noise))
                    tif_str = r"$T_\mathrm{IF}^\prime$"
                if if_noise_corr is not None:
                    ax2.plot(v_intercept, if_noise_corr, 'b*', ms=10, label="{}: {:.1f} K".format(tif_str, if_noise_corr))
            ax2.legend(loc=4, frameon=True)
            ax2.set_ylabel("IF Power (K)")
            ax2.set_xlabel("Voltage (mV)")
            ax2.set_ylim(ymin=0)
            plt.show()

            filename = ask_filename()
            if filename is None:
                print("\n\tNot saving any data.\n")
            else:
                # Save data
                header = "Voltage (mV), Current (uA), IF power (K)"
                np.savetxt(filename + ".dat", np.vstack((voltage, current, ifpower)).T, header=header)
                # Save metadata
                with open(filename + ".mdat", "w") as fout:
                    json.dump(param1, fout, indent=4)

            bias1.set_control_voltage(param1['VCTRL'], vlimit=param1['VLIMIT'])
            print(f"\n\tControl voltage (channel 1) returned to {param1['VCTRL']:.2f} V.\n")

        # MEASURE2: Measure IV / IF curve
        elif command[0] == "M2":

            # Print help
            if len(command) == 2 and command[1].upper() == "H":
                print("\n\tMeasure I-V/IF curves (channel 2)\n")
                print("\tUsage: MEASURE2 <npts> <average> <sleeptime>")
                print("\t        M2 <npts> <average> <sleeptime>")
                print("\twhere <npts> is the number of points (default 1001)")
                print("\t      <average> is the averaging (default 64)")
                print("\t      <sleeptime> is the sleep time between points (default 0.1)\n")
                continue

            print("\n\tMEASURE I-V + IF CURVE (CHANNEL 2):")

            # arg 1: number of points
            if len(command) > 1:
                npts = int(command[1])
            else:
                npts = 1001

            # arg 2: averaging
            if len(command) > 2:
                average = int(command[2])
            else:
                average = 64

            # arg 3: sleep time
            if len(command) > 3:
                sleep_time = float(command[3])
            else:
                sleep_time = 0.1

            # Parameters
            vmin, vmax = param2["VMIN"], param2["VMAX"]
            vbmin = vmin * 1000 / bias2.config['VMON']['GAIN']
            vbmax = vmax * 1000 / bias2.config['VMON']['GAIN']
            vctrl_sweep = np.linspace(vmin, vmax, npts)
            print(f"\n\tControl voltage sweep: {vmin:5.1f} to {vmax:5.1f} V")
            print(f"  \tBias voltage sweep:    {vbmin:5.1f} to {vbmax:5.1f} mV\n")

            # Sweep bias voltage and measure voltage / current / IF power
            try:
                voltage = np.zeros(npts)
                current = np.zeros(npts)
                ifpower = np.zeros(npts)
                for i, _vctrl in np.ndenumerate(vctrl_sweep):
                    bias2.set_control_voltage(_vctrl, vlimit=param2['VLIMIT'])
                    time.sleep(sleep_time)
                    voltage[i], current[i], ifpower[i] = bias2.read_all(average=average)
                    progress_bar(i[0] + 1, len(vctrl_sweep), prefix="\tProgress: ")
            except KeyboardInterrupt:
                print("")
                plt.close('all')
                bias2.set_control_voltage(param2['VCTRL'], vlimit=param2['VLIMIT'])
                print(f"\n\tControl voltage (channel 2) returned to {param2['VCTRL']:.2f} V.\n")
                continue
            bias2.set_control_voltage(param2['VCTRL'])

            # Sort by voltage
            idx = voltage.argsort()
            voltage, current, ifpower = voltage[idx], current[idx], ifpower[idx]

            # Find intercept, normal resistance and IF noise
            print(f"\n\tRange for linear fit:\t{param2['VBMIN_LINEAR']:5.1f} to {param2['VBMAX_LINEAR']:5.1f} mV")
            if param2['FREQ'] == 0:
                mask = (param2['VBMIN_LINEAR'] <= voltage) & (voltage <= param2['VBMAX_LINEAR'])
                try:
                    pnormal = np.polyfit(voltage[mask], current[mask], 1)
                    v_intercept = -pnormal[1] / pnormal[0]
                    print(f"\n\tIntercept:\t\t{v_intercept:.3f} mV")
                    rnormal = 1000 / pnormal[0]
                    print(f"  \tNormal resistance:\t{rnormal:.1f} ohms")
                    pifnoise = np.polyfit(voltage[mask], ifpower[mask], 1)
                    if_noise = np.polyval(pifnoise, v_intercept)
                    gamma = (50 - rnormal) / (50 + rnormal)
                    gmismatch = 1 - np.abs(gamma) ** 2
                    if_noise_corr = (if_noise - 1.3) * gmismatch
                    print(f"  \tIF noise:\t\t{if_noise:.1f} K")
                    print(f"  \t         \t\t{if_noise_corr:.1f} K (after correction)")
                    print(f"  \tMean IF power:\t\t{np.mean(ifpower):.1f} K\n")
                except:
                    pnormal = None
                    pifnoise = None
                    v_intercept = None 
                    rnormal = None 
                    if_noise = None
                    if_noise_corr = None
                    pass

            # Plot I-V curve
            fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5))
            ax1.plot(voltage, current, 'k-', label='I-V curve')
            if vmin == -vmax:
                ax1.plot(-voltage, -current, 'k-', alpha=0.5)
            if param2['FREQ'] == 0:
                if pnormal is not None:
                    ax1.plot(voltage[voltage > 0], np.polyval(pnormal, voltage[voltage > 0]), 'r-', lw=0.5, label=r"$R_n={:.1f}~\Omega$".format(rnormal))
                if v_intercept is not None:
                    ax1.plot(v_intercept, 0, 'r*', ms=10, label="$x$-intercept")
            ax1.set_xlabel("Voltage (mV)")
            ax1.set_ylabel("Current (uA)")
            ax1.legend(loc=2, frameon=True)

            # Plot IF power
            ax2.plot(voltage, ifpower, 'k-', label='IF power')
            if vmin == -vmax:
                ax2.plot(-voltage, ifpower, 'k-', alpha=0.5)
            if param2['FREQ'] == 0:
                if pifnoise is not None:
                    ax2.plot(voltage, np.polyval(pifnoise, voltage), 'r-', lw=0.5)
                    tif_str = r"$T_\mathrm{IF}$"
                if v_intercept is not None and if_noise is not None:
                    ax2.plot(v_intercept, if_noise, 'r*', ms=10, label="{}: {:.1f} K".format(tif_str, if_noise))
                    tif_str = r"$T_\mathrm{IF}^\prime$"
                if if_noise_corr is not None:
                    ax2.plot(v_intercept, if_noise_corr, 'b*', ms=10, label="{}: {:.1f} K".format(tif_str, if_noise_corr))
            ax2.legend(loc=4, frameon=True)
            ax2.set_ylabel("IF Power (K)")
            ax2.set_xlabel("Voltage (mV)")
            ax2.set_ylim(ymin=0)
            plt.show()

            filename = ask_filename()
            if filename is None:
                print("\n\tNot saving any data.\n")
            else:
                # Save data
                header = "Voltage (mV), Current (uA), IF power (K)"
                np.savetxt(filename + ".dat", np.vstack((voltage, current, ifpower)).T, header=header)
                # Save metadata
                with open(filename + ".mdat", "w") as fout:
                    json.dump(param2, fout, indent=4)

            bias2.set_control_voltage(param2['VCTRL'], vlimit=param2['VLIMIT'])
            print(f"\n\tControl voltage (channel 2) returned to {param2['VCTRL']:.2f} V.\n")

        # YFAC: Measure Y-factor
        elif command[0] == "Y":

            # Print help
            if len(command) == 2 and command[1].upper() == "H":
                print("\n\tMeasure Y-factor (one channel at a time)\n")
                print("\tUsage: YFAC <npts> <average> <sleeptime>")
                print("\t        Y <npts> <average> <sleeptime>")
                print("\twhere <npts> is the number of points (default 201)")
                print("\t      <average> is the averaging (default 64)")
                print("\t      <sleeptime> is the sleep time between points (default 0.1)\n")
                continue

            print("\n\tMEASURE Y-FACTOR (ONE CHANNEL AT A TIME):")

            # arg 1: number of points
            if len(command) > 1:
                npts = int(command[1])
            else:
                npts = 201

            # arg 2: averaging
            if len(command) > 2:
                average = int(command[2])
            else:
                average = 64

            # arg 3: sleep time
            if len(command) > 3:
                sleep_time = float(command[3])
            else:
                sleep_time = 0.1

            # Parameters
            vmin, vmax, vlimit = param1["VMIN"], param1["VMAX"], param1["VLIMIT"]
            vbmin, vbmax = vmin * 1000 / bias1.config['VMON']['GAIN'], vmax * 1000 / bias1.config['VMON']['GAIN']
            print(f"\n\tBias voltage sweep:    {vbmin:4.1f} to {vbmax:4.1f} mV")
            print(f"  \tControl voltage sweep: {vmin:4.1f} to {vmax:4.1f} V\n")
            print(f"  \tNumber of points: {npts}")
            print(f"  \tAveraging: {average}")
            print(f"  \tSleep time: {sleep_time:.1f} s\n")

            # Start with channel 1
            print("\tCHANNEL 1:\n")
            bias2.set_control_voltage(param2['VCTRL'])
            print(f"\tBias voltage (ch. 2) set to {param2['VCTRL']*1000/bias2.config['VMON']['GAIN']:.2f} mV\n")

            # Hot load
            bias2.hot_load()
            time.sleep(1)
            vctrl_sweep = np.linspace(vmin, vmax, npts)
            try:
                results1 = np.zeros((3, npts))
                for i, _vctrl in np.ndenumerate(vctrl_sweep):
                    bias1.set_control_voltage(_vctrl, vlimit=vlimit)
                    time.sleep(sleep_time)
                    results1[:, i] = np.array(bias1.read_all(average=average, stats=False, calibrate=True)).reshape(3, 1)
                    progress_bar(i[0] + 1, len(vctrl_sweep), prefix="\tHot load (ch. 1):  ")
            except KeyboardInterrupt:
                print("")
                plt.close('all')
                bias1.set_control_voltage(param1['VCTRL'], vlimit=param1['VLIMIT'])
                print(f"\n\tControl voltage (channel 1) returned to {param1['VCTRL']:.2f} V.")
                continue
            vh1, ih1, ph1 = results1[:, results1[0, :].argsort()]

            # Cold load
            bias2.cold_load()
            time.sleep(1)
            vctrl_sweep = np.linspace(vmin, vmax, npts)
            try:
                results1 = np.zeros((3, npts))
                for i, _vctrl in np.ndenumerate(vctrl_sweep):
                    bias1.set_control_voltage(_vctrl, vlimit=vlimit)
                    time.sleep(sleep_time)
                    results1[:, i] = np.array(bias1.read_all(average=average, stats=False, calibrate=True)).reshape(3, 1)
                    progress_bar(i[0] + 1, len(vctrl_sweep), prefix="\tCold load (ch. 1): ")
            except KeyboardInterrupt:
                print("")
                plt.close('all')
                bias1.set_control_voltage(param1['VCTRL'], vlimit=param1['VLIMIT'])
                print(f"\n\tControl voltage (channel 1) returned to {param1['VCTRL']:.2f} V.")
                continue
            vc1, ic1, pc1 = results1[:, results1[0, :].argsort()]

            # Then do channel 2
            print("\n\tCHANNEL 2:\n")
            bias1.set_control_voltage(param1['VCTRL'])
            print(f"\tBias voltage (ch. 1) set to {param1['VCTRL']*1000/bias1.config['VMON']['GAIN']:.2f} mV\n")

            # Hot load
            bias2.hot_load()
            time.sleep(1)
            vctrl_sweep = np.linspace(vmin, vmax, npts)
            try:
                results2 = np.zeros((3, npts))
                for i, _vctrl in np.ndenumerate(vctrl_sweep):
                    bias2.set_control_voltage(_vctrl, vlimit=vlimit)
                    time.sleep(sleep_time)
                    results2[:, i] = np.array(bias2.read_all(average=average, stats=False, calibrate=True)).reshape(3, 1)
                    progress_bar(i[0] + 1, len(vctrl_sweep), prefix="\tHot load (ch. 2):  ")
            except KeyboardInterrupt:
                print("")
                plt.close('all')
                bias2.set_control_voltage(param2['VCTRL'], vlimit=param2['VLIMIT'])
                print(f"\n\tControl voltage (channel 2) returned to {param2['VCTRL']:.2f} V.")
                continue
            results2h = results2[:, results2[0, :].argsort()]
            vh2, ih2, ph2 = results2h

            # Cold load
            bias2.cold_load()
            time.sleep(1)
            vctrl_sweep = np.linspace(vmin, vmax, npts)
            try:
                results2 = np.zeros((3, npts))
                for i, _vctrl in np.ndenumerate(vctrl_sweep):
                    bias2.set_control_voltage(_vctrl, vlimit=vlimit)
                    time.sleep(sleep_time)
                    results2[:, i] = np.array(bias2.read_all(average=average, stats=False, calibrate=True)).reshape(3, 1)
                    progress_bar(i[0] + 1, len(vctrl_sweep), prefix="\tCold load (ch. 2): ")
            except KeyboardInterrupt:
                print("")
                plt.close('all')
                bias2.set_control_voltage(param2['VCTRL'], vlimit=param2['VLIMIT'])
                print(f"\n\tControl voltage (channel 2) returned to {param2['VCTRL']:.2f} V.")
                continue
            vc2, ic2, pc2 = results2[:, results2[0, :].argsort()]

            # Interpolate to common voltage
            vb_min = max(vh1.min(), vc1.min(), vh2.min(), vc2.min())
            vb_max = min(vh1.max(), vc1.max(), vh2.max(), vc2.max())
            v = np.linspace(vb_min, vb_max, npts)
            ih1 = np.interp(v, vh1, ih1)
            ih2 = np.interp(v, vh2, ih2)
            ic1 = np.interp(v, vc1, ic1)
            ic2 = np.interp(v, vc2, ic2)
            ph1 = np.interp(v, vh1, ph1)
            ph2 = np.interp(v, vh2, ph2)
            pc1 = np.interp(v, vc1, pc1)
            pc2 = np.interp(v, vc2, pc2)
            vh1, vc1 = v.copy(), v.copy()
            vh2, vc2 = v.copy(), v.copy()

            # Calculate noise temperature
            yfac1 = ph1 / pc1
            yfac2 = ph2 / pc2
            tn1 = (293 - yfac1 * 78) / (yfac1 - 1)
            tn2 = (293 - yfac2 * 78) / (yfac2 - 1)
            tn1[tn1 < 0] = 1e10
            tn2[tn2 < 0] = 1e10
            gain1 = (ph1 - pc1) / (293 - 78)
            gain2 = (ph2 - pc2) / (293 - 78)

            # Plot I-V curve
            fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5))
            ax3 = ax2.twinx()
            ax1.plot(v, ih1, 'r', label='Hot (channel 1)')
            ax1.plot(v, ih2, 'r--', label='Hot (channel 2)')
            ax1.plot(v, ic1, 'b', label='Cold (channel 1)')
            ax1.plot(v, ic2, 'b--', label='Cold (channel 2)')
            ax1.set_xlabel("Voltage (mV)")
            ax1.set_ylabel("Current (uA)")
            ax1.legend(loc=2, frameon=True)

            # Plot IF power
            ax2.plot(v, ph1, 'r', label='Hot (channel 1)')
            ax2.plot(v, ph2, 'r--', label='Hot (channel 2)')
            ax2.plot(v, pc1, 'b', label='Cold (channel 1)')
            ax2.plot(v, pc2, 'b--', label='Cold (channel 2)')
            ax3.plot(v, tn1, 'g', label=r"$T_n$ (channel 1)")
            ax3.plot(v, tn2, 'g--', label=r"$T_n$ (channel 2)")
            ax3.set_ylabel("Noise Temperature (K)")
            ax2.set_ylabel("IF Power (K)")
            ax2.set_xlabel("Voltage (mV)")
            ax2.legend(loc=2, frameon=True)
            ax3.legend(loc=1, frameon=True)
            ax3.set_ylim([0, 300])
            ax2.set_ylim(ymin=0)
            plt.show()

            filename1 = ask_filename(msg="\tFile name (channel 1): ")
            filename2 = ask_filename(msg="\tFile name (channel 2): ")
            if filename1 is None:
                print("\n\tNot saving any data for channel 1.\n")
            else:
                # Save data
                header = "Voltage (mV), Hot Current (uA), Cold Current (uA), Hot IF power (K), Cold IF power (K), Noise Temperature (K), Gain"
                np.savetxt(filename1 + ".dat", np.vstack((v, ih1, ic1, ph1, pc1, tn1, gain1)).T, header=header)
                fig.savefig(filename1 + ".png", dpi=600)
                # Save metadata
                with open(filename1 + ".mdat", "w") as fout:
                    json.dump(param1, fout, indent=4)
            if filename2 is None:
                print("\n\tNot saving any data for channel 2.\n")
            else:
                # Save data
                header = "Voltage (mV), Hot Current (uA), Cold Current (uA), Hot IF power (K), Cold IF power (K), Noise Temperature (K), Gain"
                np.savetxt(filename2 + ".dat", np.vstack((v, ih2, ic2, ph2, pc2, tn2, gain2)).T, header=header)
                fig.savefig(filename2 + ".png", dpi=600)
                # Save metadata
                with open(filename2 + ".mdat", "w") as fout:
                    json.dump(param2, fout, indent=4)

            bias1.set_control_voltage(param1['VCTRL'], vlimit=param1['VLIMIT'])
            bias2.set_control_voltage(param2['VCTRL'], vlimit=param2['VLIMIT'])
            print(f"\n\tControl voltage (channel 1) returned to {param1['VCTRL']:.2f} V.")
            print(f"\n\tControl voltage (channel 2) returned to {param2['VCTRL']:.2f} V.\n")

        # YFAC: Measure Y-factor (sweep both together)
        elif command[0] == "YT":

            # Print help
            if len(command) == 2 and command[1].upper() == "H":
                print("\n\tMeasure Y-factor (sweep both channels together)\n")
                print("\tUsage: YT <npts> <average> <sleeptime>")
                print("\twhere <npts> is the number of points (default 201)")
                print("\t      <average> is the averaging (default 64)")
                print("\t      <sleeptime> is the sleep time between points (default 0.1)\n")
                continue

            print("\n\tMEASURE Y-FACTOR (SWEEP BOTH CHANNELS TOGETHER):")

            # arg 1: number of points
            if len(command) > 1:
                npts = int(command[1])
            else:
                npts = 201

            # arg 2: averaging
            if len(command) > 2:
                average = int(command[2])
            else:
                average = 64

            # arg 3: sleep time
            if len(command) > 3:
                sleep_time = float(command[3])
            else:
                sleep_time = 0.1

            # Parameters
            vmin, vmax, vlimit = param1["VMIN"], param1["VMAX"], param1["VLIMIT"]
            vbmin, vbmax = vmin * 1000 / bias1.config['VMON']['GAIN'], vmax * 1000 / bias1.config['VMON']['GAIN']
            print(f"\n\tBias voltage sweep:    {vbmin:4.1f} to {vbmax:4.1f} mV")
            print(f"  \tControl voltage sweep: {vmin:4.1f} to {vmax:4.1f} V\n")
            print(f"  \tNumber of points: {npts}")
            print(f"  \tAveraging: {average}")
            print(f"  \tSleep time: {sleep_time:.1f} s\n")

            # Hot load
            bias2.hot_load()
            time.sleep(1)
            vctrl_sweep = np.linspace(vmin, vmax, npts)
            try:
                results1 = np.zeros((3, npts))
                results2 = np.zeros((3, npts))
                for i, _vctrl in np.ndenumerate(vctrl_sweep):
                    bias1.set_control_voltage(_vctrl, vlimit=vlimit)
                    bias2.set_control_voltage(_vctrl, vlimit=vlimit)
                    time.sleep(sleep_time)
                    results1[:, i] = np.array(bias1.read_all(average=average, stats=False, calibrate=True)).reshape(3, 1)
                    results2[:, i] = np.array(bias2.read_all(average=average, stats=False, calibrate=True)).reshape(3, 1)
                    progress_bar(i[0] + 1, len(vctrl_sweep), prefix="\tHot load: ")
            except KeyboardInterrupt:
                print("")
                plt.close('all')
                bias1.set_control_voltage(param1['VCTRL'], vlimit=param1['VLIMIT'])
                print(f"\n\tControl voltage (channel 1) returned to {param1['VCTRL']:.2f} V.")
                continue
            vh1, ih1, ph1 = results1[:, results1[0, :].argsort()]
            vh2, ih2, ph2 = results2[:, results2[0, :].argsort()]

            # Cold load
            bias2.cold_load()
            time.sleep(1)
            vctrl_sweep = np.linspace(vmin, vmax, npts)
            try:
                results1 = np.zeros((3, npts))
                results2 = np.zeros((3, npts))
                for i, _vctrl in np.ndenumerate(vctrl_sweep):
                    bias1.set_control_voltage(_vctrl, vlimit=vlimit)
                    bias2.set_control_voltage(_vctrl, vlimit=vlimit)
                    time.sleep(sleep_time)
                    results1[:, i] = np.array(bias1.read_all(average=average, stats=False, calibrate=True)).reshape(3, 1)
                    results2[:, i] = np.array(bias2.read_all(average=average, stats=False, calibrate=True)).reshape(3, 1)
                    progress_bar(i[0] + 1, len(vctrl_sweep), prefix="\tCold load:")
            except KeyboardInterrupt:
                print("")
                plt.close('all')
                bias1.set_control_voltage(param1['VCTRL'], vlimit=param1['VLIMIT'])
                print(f"\n\tControl voltage (channel 1) returned to {param1['VCTRL']:.2f} V.")
                continue
            vc1, ic1, pc1 = results1[:, results1[0, :].argsort()]
            vc2, ic2, pc2 = results2[:, results2[0, :].argsort()]

            # Interpolate to common voltage
            vb_min = max(vh1.min(), vc1.min(), vh2.min(), vc2.min())
            vb_max = min(vh1.max(), vc1.max(), vh2.max(), vc2.max())
            v = np.linspace(vb_min, vb_max, npts)
            ih1 = np.interp(v, vh1, ih1)
            ih2 = np.interp(v, vh2, ih2)
            ic1 = np.interp(v, vc1, ic1)
            ic2 = np.interp(v, vc2, ic2)
            ph1 = np.interp(v, vh1, ph1)
            ph2 = np.interp(v, vh2, ph2)
            pc1 = np.interp(v, vc1, pc1)
            pc2 = np.interp(v, vc2, pc2)
            vh1, vc1 = v.copy(), v.copy()
            vh2, vc2 = v.copy(), v.copy()

            # Calculate noise temperature
            yfac1 = ph1 / pc1
            yfac2 = ph2 / pc2
            tn1 = (293 - yfac1 * 78) / (yfac1 - 1)
            tn2 = (293 - yfac2 * 78) / (yfac2 - 1)
            tn1[tn1 < 0] = 1e10
            tn2[tn2 < 0] = 1e10
            gain1 = (ph1 - pc1) / (293 - 78)
            gain2 = (ph2 - pc2) / (293 - 78)

            # Plot I-V curve
            fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5))
            ax3 = ax2.twinx()
            ax1.plot(v, ih1, 'r', label='Hot (channel 1)')
            ax1.plot(v, ih2, 'r--', label='Hot (channel 2)')
            ax1.plot(v, ic1, 'b', label='Cold (channel 1)')
            ax1.plot(v, ic2, 'b--', label='Cold (channel 2)')
            ax1.set_xlabel("Voltage (mV)")
            ax1.set_ylabel("Current (uA)")
            ax1.legend(loc=2, frameon=True)

            # Plot IF power
            ax2.plot(v, ph1, 'r', label='Hot (channel 1)')
            ax2.plot(v, ph2, 'r--', label='Hot (channel 2)')
            ax2.plot(v, pc1, 'b', label='Cold (channel 1)')
            ax2.plot(v, pc2, 'b--', label='Cold (channel 2)')
            ax3.plot(v, tn1, 'g', label=r"$T_n$ (channel 1)")
            ax3.plot(v, tn2, 'g--', label=r"$T_n$ (channel 2)")
            ax3.set_ylabel("Noise Temperature (K)")
            ax2.set_ylabel("IF Power (K)")
            ax2.set_xlabel("Voltage (mV)")
            ax2.legend(loc=2, frameon=True)
            ax3.legend(loc=1, frameon=True)
            ax3.set_ylim([0, 300])
            ax2.set_ylim(ymin=0)
            plt.show()

            filename1 = ask_filename(msg="\tFile name (channel 1): ")
            filename2 = ask_filename(msg="\tFile name (channel 2): ")
            if filename1 is None:
                print("\n\tNot saving any data for channel 1.\n")
            else:
                # Save data
                header = "Voltage (mV), Hot Current (uA), Cold Current (uA), Hot IF power (K), Cold IF power (K), Noise Temperature (K), Gain"
                np.savetxt(filename1 + ".dat", np.vstack((v, ih1, ic1, ph1, pc1, tn1, gain1)).T, header=header)
                fig.savefig(filename1 + ".png", dpi=600)
                # Save metadata
                with open(filename1 + ".mdat", "w") as fout:
                    json.dump(param1, fout, indent=4)
            if filename2 is None:
                print("\n\tNot saving any data for channel 2.\n")
            else:
                # Save data
                header = "Voltage (mV), Hot Current (uA), Cold Current (uA), Hot IF power (K), Cold IF power (K), Noise Temperature (K), Gain"
                np.savetxt(filename2 + ".dat", np.vstack((v, ih2, ic2, ph2, pc2, tn2, gain2)).T, header=header)
                fig.savefig(filename2 + ".png", dpi=600)
                # Save metadata
                with open(filename2 + ".mdat", "w") as fout:
                    json.dump(param2, fout, indent=4)

            bias1.set_control_voltage(param1['VCTRL'], vlimit=param1['VLIMIT'])
            bias2.set_control_voltage(param2['VCTRL'], vlimit=param2['VLIMIT'])
            print(f"\n\tControl voltage (channel 1) returned to {param1['VCTRL']:.2f} V.")
            print(f"\n\tControl voltage (channel 2) returned to {param2['VCTRL']:.2f} V.\n")

        # YIF: Measure Y-factor vs IF frequency
        elif command[0] == "YIF":

            # Print help
            if len(command) == 2 and command[1].upper() == "H":
                print("\n\tMeasure Y-factor versus IF frequency\n")
                print("\tUseage: YIF <start> <stop> <step> <average>")
                print("\twhere <start> is the start frequency, in units GHz (default 3)")
                print("\t      <stop> is the stop frequency, in units GHz (default 25)")
                print("\t      <step> is the frequency step, in units GHz (default 0.1)")
                print("\t      <average> is the number of points to average (default 100)\n")
                continue

            print("\n\tMEASURE Y-FACTOR VS IF FREQUENCY:\n")

            # arg 1: start
            if len(command) > 1:
                start = float(command[1])
            else:
                start = 3.0

            # arg 2: stop
            if len(command) > 2:
                stop = float(command[2])
            else:
                stop = 20.0

            # arg 3: step
            if len(command) > 3:
                step = float(command[3])
            else:
                step = 0.1

            # arg 4: average
            if len(command) > 4:
                average = float(command[3])
            else:
                average = 100

            # Hot load
            bias2.hot_load()
            time.sleep(1)

            # Measure IF power
            try:
                if_frequency = np.arange(start, stop+1e-10, step)
                if_power1h = np.empty_like(if_frequency)
                if_power2h = np.empty_like(if_frequency)
                if_power1h_std = np.empty_like(if_frequency)
                if_power2h_std = np.empty_like(if_frequency)
                for i, _if_freq in np.ndenumerate(if_frequency):
                    if_filter1.set_frequency(_if_freq)
                    if_filter2.set_frequency(_if_freq)
                    time.sleep(0.1)
                    if_power1h[i], if_power1h_std[i] = bias1.read_ifpower(average=average, stats=True)
                    if_power2h[i], if_power2h_std[i] = bias2.read_ifpower(average=average, stats=True)
                    progress_bar(i[0] + 1, len(if_frequency), prefix="\tHot load: ")
            except KeyboardInterrupt:
                print("")
                plt.close('all')
                continue

            # Cold load
            bias2.cold_load()
            time.sleep(1)

            # Measure IF power
            try:
                if_frequency = np.arange(start, stop+1e-10, step)
                if_power1c = np.empty_like(if_frequency)
                if_power2c = np.empty_like(if_frequency)
                if_power1c_std = np.empty_like(if_frequency)
                if_power2c_std = np.empty_like(if_frequency)
                for i, _if_freq in np.ndenumerate(if_frequency):
                    if_filter1.set_frequency(_if_freq)
                    if_filter2.set_frequency(_if_freq)
                    time.sleep(0.1)
                    if_power1c[i], if_power1c_std[i] = bias1.read_ifpower(average=average, stats=True)
                    if_power2c[i], if_power2c_std[i] = bias2.read_ifpower(average=average, stats=True)
                    progress_bar(i[0] + 1, len(if_frequency), prefix="\tCold load:")
            except KeyboardInterrupt:
                print("")
                plt.close('all')
                continue

            # Return to previous IF frequency
            if_filter1.set_frequency(param1['IFFREQ'])
            if_filter2.set_frequency(param2['IFFREQ'])

            # Y-factor
            yfac1 = if_power1h / if_power1c
            yfac2 = if_power2h / if_power2c

            # Noise temperature
            tn1 = (293 - yfac1 * 78) / (yfac1 - 1)
            tn2 = (293 - yfac2 * 78) / (yfac2 - 1)

            # Gain
            gain1 = (if_power1h - if_power1c) / (293 - 78)
            gain2 = (if_power2h - if_power2c) / (293 - 78)

            # Plot
            fig, (ax1, ax2, ax3) = plt.subplots(3, figsize=(12, 8))
            fig.subplots_adjust(hspace=0)
            ax1.plot(if_frequency, if_power1h, 'r',   label="Ch1: hot")
            ax1.plot(if_frequency, if_power1c, 'b',   label="Ch1: cold")
            ax1.plot(if_frequency, if_power2h, 'r--', label="Ch2: hot")
            ax1.plot(if_frequency, if_power2c, 'b--', label="Ch1: cold")
            
            ax2.plot(if_frequency, tn1, 'g',   label="Ch1: noise")
            ax2.plot(if_frequency, tn2, 'g--', label="Ch2: noise")

            ax3.plot(if_frequency, 10*np.log10(abs(gain1)), 'k',   label="Ch1: gain")
            ax3.plot(if_frequency, 10*np.log10(abs(gain2)), 'k--', label="Ch2: gain")
            
            ax1.set_ylabel("IF power (K)")
            ax2.set_ylabel("Noise temp. (K)")
            ax3.set_ylabel("Gain (dB)")
            ax3.set_xlabel("IF frequency (GHz)")
            ax1.set_ylim(ymin=0)
            ax2.set_ylim([0, 249])
            ax1.set_xlim([if_frequency.min(), if_frequency.max()])
            ax2.set_xlim([if_frequency.min(), if_frequency.max()])
            ax3.set_xlim([if_frequency.min(), if_frequency.max()])
            ax1.legend(frameon=True, framealpha=1)
            ax2.legend(frameon=True, framealpha=1)
            ax3.legend(frameon=True, framealpha=1)
            plt.show()

            # Save data
            filename = ask_filename()
            if filename is None:
                print("\tNot any saving data.\n")
            else:
                # Save data
                header = "IF frequency (GHz), IF power 1 hot (K), IF power 1 cold (K), IF power 2 hot (K), IF power 2 cold (K), Tn 1 (K), Tn 2 (K), G 1, G 2"
                np.savetxt(filename + ".dat", np.vstack((if_frequency, if_power1h, if_power1c, if_power2h, if_power2c, tn1, tn2, gain1, gain2)).T, header=header)
                # Save metadata
                with open(filename + ".mdat", "w") as fout:
                    json.dump(param1, fout, indent=4)
                    json.dump(param2, fout, indent=4)
                # Save figure
                fig.savefig(filename + ".png")

        # 2SB measurements ------------------------------------------------- #

        # TONE: Control tone injection
        elif command[0] == "TONE":

            # Print help
            if len(command) == 2 and command[1].upper() == "H":
                print("\n\tControl tone injection\n")
                print("\tUsage: TONE <offset> <power>\n")
                continue

            print("\n\tSET TONE FREQUENCY + POWER:\n")

            # arg 1: tone offset frequency
            if len(command) > 1:
                tone_offset = float(command[1])
            else:
                tone_offset = 6

            # arg 2: power (dBm)
            if len(command) > 2:
                power_dbm = float(command[2])
            else:
                power_dbm = -20

            # Maximum power
            if power_dbm > 5:
                print("\tWarning: Power too high! Limiting to 5 dBm\n")
                power_dbm = 5

            # Get local oscillator frequency
            local_oscillator = param1['FREQ']
            assert param1['FREQ'] == param2['FREQ']
            print(f"\t-> LO frequency:   {local_oscillator:7.3f} GHz")

            # Tone LO chain parameters
            tone_fmult = 9

            # Set tone frequency
            tone_frequency = local_oscillator + tone_offset
            tone_synth_frequency = tone_frequency / tone_fmult
            print(f"\t-> Tone offset:    {tone_offset:7.3f} GHz")
            print(f"\t-> Tone frequency: {tone_frequency:7.3f} GHz")
            print(f"\t             mult: {tone_fmult:3d}")
            print(f"\t            synth: {tone_synth_frequency:7.3f} GHz")
            tone_synth.set_frequency(tone_synth_frequency)

            # Set filter frequencies
            param1['IFFREQ'] = abs(tone_offset)
            param2['IFFREQ'] = abs(tone_offset)
            if_filter1.set_frequency(abs(tone_offset))
            if_filter2.set_frequency(abs(tone_offset))

            # Set tone power
            print(f"\t-> Tone power:     {power_dbm:7.3f} dBm")
            print(f"\t                   {10**(power_dbm/10):7.3f} mW\n")
            tone_synth.set_power(power_dbm, 'dbm')

            # Turn on synthesizer
            tone_synth.power_on()

            # Read IF power resulting from tone injection
            time.sleep(2)
            _ = bias1.read_ifpower(average=2000, verbose=True, msg="\tIF power (channel 1)")
            _ = bias2.read_ifpower(average=2000, verbose=True, msg="\tIF power (channel 2)")

        # IRR: Measure image rejection ratio
        elif command[0] == "IRR":

            # Print help
            if len(command) == 2 and command[1].upper() == "H":
                print("\n\tMeasure image rejection ratio\n")
                print("\tUsage: IRR\n")
                continue

            print("\n\tMEASURE IMAGE REJECTION RATIO:\n")

            # Debug?
            debug = True 
            plot = True
            verbose = False

            # arg 1: start frequency, GHz
            if len(command) > 1:
                tone_start = float(command[1])
            else:
                tone_start = 6

            # arg 2: stop frequency, GHz
            if len(command) > 2:
                tone_stop = float(command[2])
            else:
                tone_stop = 8

            # arg 3: frequency step, GHz
            if len(command) > 3:
                tone_step = float(command[3])
            else:
                tone_step = 1

            # Start with cold load
            bias2.cold_load()

            # Get local oscillator frequency
            local_oscillator = param1['FREQ']
            assert local_oscillator == param2['FREQ']
            assert local_oscillator != 0, 'Local oscillator frequency not specified'
            print(f"\t-> LO frequency: {local_oscillator:5.1f} GHz\n")
            print(f"\t-> Tone offset:  {tone_start:4.2f} to {tone_stop:4.2f} GHz, {tone_step:4.2f} GHz step\n")

            # Sweep parameters
            # TODO: make into arguments?
            sleep_time = 0.5
            average = 2000

            # Tone parameters
            tone_fmult = 9  # frequency multiplication of tone LO chain
            tone_sweep = np.arange(tone_start, tone_stop + 1e-10, tone_step)
            npts = len(tone_sweep)

            # Inject LSB tone (M_L in Kerr 2001)
            print("\t-> Measuring lower sideband ratio (M_LSB)...")
            p1lsb, p2lsb = np.zeros(npts), np.zeros(npts)
            for i, tone_offset in np.ndenumerate(tone_sweep):
                # Setup tone
                tone_synth_power = -5  # starting power (dBm)
                tone_synth_freq = (local_oscillator - tone_offset) / tone_fmult
                tone_synth.set_power(tone_synth_power, 'dbm')
                tone_synth.set_frequency(tone_synth_freq)
                tone_synth.power_on()
                if verbose:
                    print(f"\t\tTone offset: {-tone_offset:.2f} GHz ({i[0]} / {npts})")  # debug
                else:
                    progress_bar(i[0]+1, npts, prefix='\t\tProgress: ', suffix='', length=50)
                # Setup IF filters
                if_filter1.set_frequency(abs(tone_offset))
                if_filter2.set_frequency(abs(tone_offset))
                time.sleep(sleep_time)
                # Wait extra long if it's first step
                if i[0] == 0:
                    time.sleep(5)
                # Optimize synth power
                _ifpower = bias1.read_ifpower(average=100, offset_only=True)
                while _ifpower < 0.7:
                    tone_synth_power += 0.1
                    if tone_synth_power >= 3:  # don't go above 3 dBm
                        break
                    tone_synth.set_power(tone_synth_power, 'dbm')
                    time.sleep(0.1)
                    _ifpower = bias1.read_ifpower(average=100, offset_only=True)
                    if verbose:
                        print(f"\t\t\t{tone_synth_power:.1f} dBm -> {_ifpower*10:.3f} AU")
                # Measure IF power
                p1lsb[i], p2lsb[i] = _read_if_power(bias1, bias2, average)
                # Print info
                if verbose:
                    print(f"\t\tResults: ", end="")
                    print(f"{-tone_offset:5.1f} GHz", end=", ")
                    print(f"{tone_synth_freq:6.3f} GHz", end=", ")
                    print(f"{tone_synth_power:4.1f} dBm", end=", ")
                    print(f"{p1lsb[i]*10:6.3f} AU, {p2lsb[i]*10:6.3f} AU")

            # Inject USB tone (M_U in Kerr 2001)
            print("\t-> Measuring upper sideband ratio (M_USB)...")
            p1usb, p2usb = np.zeros(npts), np.zeros(npts)
            for i, tone_offset in np.ndenumerate(tone_sweep):
                # Setup tone
                tone_synth_power = -5  # starting power (dBm)
                tone_synth_freq = (local_oscillator + tone_offset) / tone_fmult
                tone_synth.set_power(tone_synth_power, 'dbm')
                tone_synth.set_frequency(tone_synth_freq)
                tone_synth.power_on()
                if verbose:
                    print(f"\t\tTone offset: {tone_offset:.2f} GHz")
                else:
                    progress_bar(i[0]+1, npts, prefix='\t\tProgress: ', suffix='', length=50)
                # Setup IF filters
                if_filter1.set_frequency(abs(tone_offset))
                if_filter2.set_frequency(abs(tone_offset))
                time.sleep(sleep_time)
                # Wait extra long if it's first step
                if i[0] == 0:
                    time.sleep(5)
                # Optimize synth power
                _ifpower = bias2.read_ifpower(average=100, offset_only=True)
                while _ifpower < 0.7:
                    tone_synth_power += 0.1
                    if tone_synth_power >= 3:  # don't go above 3 dBm
                        break
                    tone_synth.set_power(tone_synth_power, 'dbm')
                    time.sleep(0.1)
                    _ifpower = bias2.read_ifpower(average=100, offset_only=True)
                    if verbose:
                        print(f"\t\t\t{tone_synth_power:.1f} dBm -> {_ifpower*10:.3f} AU")
                # Measure IF power
                p1usb[i], p2usb[i] = _read_if_power(bias1, bias2, average)
                # Print info
                if verbose:
                    print(f"\t\tResults: ", end="")
                    print(f"{tone_offset:5.1f} GHz", end=", ")
                    print(f"{tone_synth_freq:6.3f} GHz", end=", ")
                    print(f"{tone_synth_power:4.1f} dBm", end=", ")
                    print(f"{p1usb[i]*10:6.3f} AU, {p2usb[i]*10:6.3f} AU")

            # Turn tone off
            tone_synth.power_off()

            # Cold load
            print("\t-> Measuring cold load...")
            bias2.cold_load()
            p1c, p2c = np.zeros_like(tone_sweep), np.zeros_like(tone_sweep)
            for i, tone_offset in np.ndenumerate(tone_sweep):
                progress_bar(i[0]+1, npts, prefix='\t\tProgress: ', suffix='', length=50)
                # Setup IF filters
                if_filter1.set_frequency(abs(tone_offset))
                if_filter2.set_frequency(abs(tone_offset))
                # Wait extra long if it's the first step
                if i[0] == 0:
                    time.sleep(5)
                else:
                    time.sleep(sleep_time)
                # Measure IF power
                p1c[i], p2c[i] = _read_if_power(bias1, bias2, average)

            # Hot load
            print("\t-> Measuring hot load...")
            bias2.hot_load()
            p1h, p2h = np.zeros_like(tone_sweep), np.zeros_like(tone_sweep)
            for i, tone_offset in np.ndenumerate(tone_sweep):
                progress_bar(i[0]+1, npts, prefix='\t\tProgress: ', suffix='', length=50)
                # Setup IF filters
                if_filter1.set_frequency(abs(tone_offset))
                if_filter2.set_frequency(abs(tone_offset))
                # Wait extra long if it's the first step
                if i[0] == 0:
                    time.sleep(5)
                else:
                    time.sleep(sleep_time)
                # Measure IF power
                p1h[i], p2h[i] = _read_if_power(bias1, bias2, average)

            # Return to cold load
            bias2.cold_load()

            # Ratio between outputs
            m_usb = abs(p2usb - p2c) / abs(p1usb - p1c)  # eqn 1
            m_lsb = abs(p1lsb - p1c) / abs(p2lsb - p2c)  # eqn 2

            # DSB noise temperature
            with np.errstate(divide='ignore',invalid='ignore'):
                yfac1 = p1h / p1c
                yfac2 = p2h / p2c
            t_dsb1 = (295 - yfac1 * 78) / (yfac1 - 1)
            t_dsb2 = (295 - yfac2 * 78) / (yfac2 - 1)

            # DSB gain ratio (M_DSB in Kerr 2001)
            delta_p1 = p1h - p1c  # eqn 3a
            delta_p2 = p2h - p2c  # eqn 3b
            with np.errstate(divide='ignore',invalid='ignore'):
                m_dsb = delta_p2 / delta_p1  # eqn 4 (USB / LSB)

            # Image rejection ratio (R_1 and R_2 in Kerr 2001)
            gain_factor = (m_lsb * m_dsb - 1) / (m_usb - m_dsb)
            r_1 = m_lsb / gain_factor  # LSB
            r_2 = m_usb * gain_factor  # USB

            # SSB noise temperature
            t_usb = t_dsb2 * (1 + 1 / r_2)
            t_lsb = t_dsb1 * (1 + 1 / r_1)

            # Debugging plots
            if debug:
                fig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(15,5))
                ax1.plot(tone_sweep, p1h, 'r',   label="Channel 1: hot")
                ax1.plot(tone_sweep, p1c, 'b',   label="Channel 1: cold")
                ax1.plot(tone_sweep, p2h, 'r--', label="Channel 2: hot")
                ax1.plot(tone_sweep, p2c, 'b--', label="Channel 2: cold")
                ax1.set_xlabel("IF frequency (GHz)")
                ax1.set_ylabel("IF power (K)")
                ax1.legend()
                ax2.plot(tone_sweep, t_dsb1, 'b', label="Channel 1 (LSB)")
                ax2.plot(tone_sweep, t_dsb2, 'r', label="Channel 2 (USB)")
                ax2.set_xlabel("IF frequency (GHz)")
                ax2.set_ylabel("DSB noise temperature (K)")
                ax2.legend()
                ax3.plot(tone_sweep, m_dsb, 'k', label=r"$M_{DSB}$")
                ax3.set_xlabel("IF frequency (GHz)")
                ax3.set_ylabel(r"DSB ratio $M_{DSB}$")
                ax3.legend()
                plt.title("Hot / cold load measurements")

                fig, ((ax3, ax4, ax5), (ax1, ax2, ax6)) = plt.subplots(2, 3, figsize=(15,8))
                ax1.plot(tone_sweep, p1c*10, 'k--', label="Channel 1: baseline")
                ax1.plot(tone_sweep, p1usb*10, 'b', label="Channel 1: with USB tone")
                ax2.plot(tone_sweep, p2c*10, 'k--', label="Channel 2: baseline")
                ax2.plot(tone_sweep, p2usb*10, 'r', label="Channel 2: with USB tone")
                ax1.set_xlabel("Tone offset frequency (GHz)")
                ax2.set_xlabel("IF frequency (GHz)")
                ax1.set_ylabel("IF power (uW)")
                ax2.set_ylabel("IF power (uW)")
                ax1.set_ylim([0, 25])
                ax2.set_ylim([0, 25])
                ax1.legend(loc=1, frameon=True, framealpha=1)
                ax2.legend(loc=1, frameon=True, framealpha=1)
                ax3.plot(tone_sweep, p1c*10, 'k--', label="Channel 1: baseline")
                ax3.plot(tone_sweep, p1lsb*10, 'b', label="Channel 1: with LSB tone")
                ax4.plot(tone_sweep, p2c*10, 'k--', label="Channel 2: baseline")
                ax4.plot(tone_sweep, p2lsb*10, 'r', label="Channel 2: with LSB tone")
                ax3.set_xlabel("Tone offset frequency (GHz)")
                ax4.set_xlabel("IF frequency (GHz)")
                ax3.set_ylabel("IF power (uW)")
                ax4.set_ylabel("IF power (uW)")
                ax3.set_ylim([0, 25])
                ax4.set_ylim([0, 25])
                ax3.legend(loc=1, frameon=True, framealpha=1)
                ax4.legend(loc=1, frameon=True, framealpha=1)
                ax5.plot(tone_sweep, 10*np.log10(m_lsb), 'b', label=r"$M_{LSB}$")
                ax6.plot(tone_sweep, 10*np.log10(m_usb), 'r', label=r"$M_{USB}$")
                ax5.set_xlabel("IF frequency (GHz)")
                ax6.set_xlabel("IF frequency (GHz)")
                ax5.set_ylabel(r"LSB Ratio $M_{LSB}$ (dB)")
                ax6.set_ylabel(r"USB Ratio $M_{USB}$ (dB)")
                ax5.set_ylim([0, 30])
                ax6.set_ylim([0, 30])
                ax5.legend(loc=1, frameon=True, framealpha=1)
                ax6.legend(loc=1, frameon=True, framealpha=1)

                plt.figure(figsize=(6,5))
                plt.plot(tone_sweep, 10*np.log10(m_lsb), 'b', label=r"$M_{LSB}$")
                plt.plot(tone_sweep, 10*np.log10(m_usb), 'r', label=r"$M_{USB}$")
                plt.plot(tone_sweep, 10*np.log10(m_dsb), 'g', label=r"$M_{DSB}$")
                plt.plot(tone_sweep, 10*np.log10(gain_factor), 'k--', label=r"Gain factor")
                plt.xlabel("IF frequency (GHz)")
                plt.ylabel("Magnitude (dB)")
                plt.legend()

            # Results plot
            if plot:
                fig, (ax2, ax1) = plt.subplots(1, 2, figsize=(12,5))
                ax1.plot(-tone_sweep, 10*np.log10(r_1),   'b',   label="R_LSB")
                ax1.plot(-tone_sweep, 10*np.log10(m_lsb), 'b--', label="M_LSB", alpha=0.5)
                ax1.plot( tone_sweep, 10*np.log10(r_2),   'r',   label="R_USB")
                ax1.plot( tone_sweep, 10*np.log10(m_usb), 'r--', label="M_USB", alpha=0.5)
                ax1.set_xlabel("Tone offset frequency (GHz)")
                ax1.set_ylabel("Rejection ratio (dB)")
                ax1.set_ylim(ymin=0)
                ax1.legend()
                ax2.plot(-tone_sweep, t_lsb, 'b', label="LSB")
                ax2.plot( tone_sweep, t_usb, 'r', label="USB")
                ax2.set_xlabel("Tone offset frequency (GHz)")
                ax2.set_ylabel("Noise temperature (K)")
                ax2.set_ylim(ymin=0)
                ax2.legend()
        
            print("")
            print(f"\t-> Output ratios:         {10*np.log10(np.mean(m_lsb)):5.1f} dB (LSB)")
            print(f"\t                          {10*np.log10(np.mean(m_usb)):5.1f} dB (USB)")
            print("")
            print(f"\t-> Image rejection ratio: {10*np.log10(np.mean(r_1)):5.1f} dB (LSB)")
            print(f"\t                          {10*np.log10(np.mean(r_2)):5.1f} dB (USB)")
            print("")
            print(f"\t-> Noise temperatures:    {np.mean(t_lsb):5.1f} K (LSB)")
            print(f"\t                          {np.mean(t_usb):5.1f} K (USB)")
            print(f"\n\t\t\t** mean values **")

            plt.show()

            filename = ask_filename(msg="\tFile name: ")
            if filename is None:
                print("\tNot saving any data.\n")
            else:
                # Save data
                header = "Offset frequency (GHz), T_LSB (K), T_USB (K), R_LSB, R_USB, M_LSB, M_USB, M_DSB, P1H, P1C, P2H, P2C"
                results = np.vstack((tone_sweep, t_lsb, t_usb, r_1, r_2, m_lsb, m_usb, m_dsb, p1h, p1c, p2h, p2c)).T
                np.savetxt(filename + ".dat", results, header=header)
                if plot:
                    fig.savefig(filename + ".png")

        # Misc measurements ------------------------------------------------ #

        # CONST: Set constant bias and monitor V + I
        elif command[0] == "CONST":

            # Print help
            if len(command) == 2 and command[1].upper() == "H":
                print("\n\tSet constant control voltage and measure statistics (channel 1)\n")
                print("\tUsage: CONST <npts>")
                print("\twhere <npts> is the number of sample points (default is 50,000)\n")
                continue

            print("\n\tCONSTANT CONTROL VOLTAGE:\n")

            # arg 1: number of sample points
            if len(command) > 1:
                npts = int(command[1])
            else:
                npts = 50_000

            results = bias1.noise_statistics(npts=npts, bias2=bias2)

            # Save data
            filename = ask_filename()
            if filename is None:
                print("\tNot any saving data.\n")
            else:
                # Save data
                header = "Time, Voltage 1 (mV), Current 1 (uA), IF Power 1 (K), Voltage 2 (mV), Current 2 (uA), IF Power 2 (K)"
                np.savetxt(filename + ".dat", results, header=header)

        # RESISTANCE: Fit resistance of I-V curve
        elif command[0] == "R":

            # Print help
            if len(command) == 2 and command[1].upper() == "H":
                print("\n\tMeasure the resistance of the I-V curve\n")
                print("\tUsage: R\n")
                continue

            print("\n\tMEASURE RESISTANCE:")

            # Parameters
            npts = 10
            sleep_time = 0.1
            average = 10
            vmin, vmax = param1["VMIN"], param1["VMAX"]
            vbmin = vmin * 1000 / bias1.config['VMON']['GAIN']
            vbmax = vmax * 1000 / bias1.config['VMON']['GAIN']
            vctrl_sweep = np.linspace(vmin, vmax, npts)
            print(f"\n\tControl voltage sweep: {vmin:5.1f} to {vmax:5.1f} V")
            print(f"  \tBias voltage sweep:    {vbmin:5.1f} to {vbmax:5.1f} mV\n")

            # Sweep bias voltage and measure voltage / current / IF power
            try:
                voltage1, voltage2 = np.zeros(npts), np.zeros(npts)
                current1, current2 = np.zeros(npts), np.zeros(npts)
                for i, _vctrl in np.ndenumerate(vctrl_sweep):
                    bias1.set_control_voltage(_vctrl, vlimit=param1['VLIMIT'])
                    bias2.set_control_voltage(_vctrl, vlimit=param2['VLIMIT'])
                    time.sleep(sleep_time)
                    voltage1[i], current1[i], _ = bias1.read_all(average=average)
                    voltage2[i], current2[i], _ = bias2.read_all(average=average)
                    progress_bar(i[0] + 1, len(vctrl_sweep), prefix="\tProgress: ")
            except KeyboardInterrupt:
                print("")
                plt.close('all')
                continue
            bias1.set_control_voltage(param1['VCTRL'])
            bias2.set_control_voltage(param2['VCTRL'])
            print("")

            # Sort by voltage
            idx = voltage1.argsort()
            voltage1, current1 = voltage1[idx], current1[idx]
            idx = voltage2.argsort()
            voltage2, current2 = voltage2[idx], current2[idx]

            p1, cov1 = np.polyfit(current1*1e-6, voltage1*1e-3, 1, cov=True)
            p2, cov2 = np.polyfit(current2*1e-6, voltage2*1e-3, 1, cov=True)
            perr1 = np.sqrt(np.diag(cov1))
            perr2 = np.sqrt(np.diag(cov2))
            print(f"\tResistance: {p1[0]:6.2f} +/- {perr1[0]:4.2f} ohms (channel 1)")
            print(f"\t            {p2[0]:6.2f} +/- {perr2[0]:4.2f} ohms (channel 2)\n")

        # Digital input/output --------------------------------------------- #

        # HOT: move load to hot position
        elif command[0] == "HOT":
            bias2.hot_load()

        # COLD: move load to cold position
        elif command[0] == "COLD":
            bias2.cold_load()

        # Misc functions --------------------------------------------------- #

        # ID: Print DAQ ID number
        elif command[0] == "ID":

            print("\n\tChannel 1: ", bias1)
            print("\n\tChannel 2: ", bias2, "\n")

        # CLEAR: Clear all plots
        elif command[0] == "CLEAR" or command[0] == "C":
            plt.close("all")

        # EXIT: Stop bias and shutdown
        elif command[0] == "EXIT" or command[0] == "Q":
            break

        # Command not recognized...
        else:
            print("\n\tCommand not recognized.\n")

except DAQNotFoundError:
    pass

except KeyboardInterrupt:
    print("\nClosing program.")

except EOFError:
    print("\nClosing program.")

except uldaq.ul_exception.ULException:
    print("\nConnection lost to device.")

except RuntimeError as e:
    print(e, "\n")
    bias1 = None
    bias2 = None

finally:
    
    if bias1 is not None:

        # Save parameters to file (for persistence)
        with open(param_filename1, 'w') as fout:
            json.dump(param1, fout, indent=4)
        print(f"\nMeasurement parameters (channel 1) saved to: {param_filename1}")
        bias1.save_cal()
        bias1.save_config()

    if bias2 is not None:

        # Save parameters to file (for persistence)
        with open(param_filename2, 'w') as fout:
            json.dump(param2, fout, indent=4)
        print(f"\nMeasurement parameters (channel 2) saved to: {param_filename2}")
        bias2.save_cal()
        bias2.save_config()

    if tone_synth is not None:
        tone_synth.set_power(0, 'dbm')
        tone_synth.power_off()

    try:
        print("")
        bias1.set_control_voltage(0, verbose=True)
        print("")
        bias2.set_control_voltage(0, verbose=True)
        print("")
        bias1.close()
        bias2.close()

    except (NameError, AttributeError, uldaq.ul_exception.ULException) as e:
        pass
