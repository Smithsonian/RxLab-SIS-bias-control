#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""Interactive script for controlling the SIS bias."""

import argparse
import json
import time
import numpy as np
import matplotlib.pyplot as plt 
import uldaq

from appdirs import user_config_dir

from sisbias import SISBias, progress_bar, ask_filename
from labinstruments.microlambda import YigFilter

try:
    plt.style.use(["science", "sans", "no-latex"])
except ModuleNotFoundError:
    print("Matplotlib styles not found")
    print("\ttry: pip install SciencePlots")
except OSError:
    print("Matplot styles not found")
    print("\ttry: pip install SciencePlots")

# ----------------------------------------------------------------------------

# Grab arguments
parser = argparse.ArgumentParser(description="Plot I-V curve and IF power in realtime.")
parser.add_argument("-c", "--configfile", type=str, help="Configuration file", default=None)
parser.add_argument("-p", "--paramfile", type=str, help="Parameter file", default=None)
parser.add_argument("--filteraddr", type=str, help="YIG filter IP address", default=None)  #"192.168.1.15")
args = parser.parse_args()

# Location of configuration file
if args.configfile is None:
    config_filename = user_config_dir("rxlab-sis-bias.config")
else:
    config_filename = args.configfile

# Read parameter file
if args.paramfile is None:
    param_filename = user_config_dir("rxlab-sis-bias.param")
else:
    param_filename = args.paramfile
with open(param_filename) as _fin:
    param = json.load(_fin)

# ----------------------------------------------------------------------------

try:
    # Initialize bias control
    bias = SISBias(config_file=config_filename)

    # Set bias voltage to zero
    param['VCTRL'] = 0
    bias.set_control_voltage(param['VCTRL'])

    # Save voltage / current gain to param (from config file)
    param["VMONGAIN"] = bias.config['VMON']['GAIN']
    param["IMONGAIN"] = bias.config['IMON']['GAIN']
    param["VMONOFFSET"] = bias.config['VMON']['OFFSET']
    param["IMONOFFSET"] = bias.config['IMON']['OFFSET']

    # Connect to IF filter
    if args.filteraddr is not None:
        if_filter = YigFilter(args.filteraddr)
        if_filter.set_frequency(param['IFFREQ'])
        print("Connected to IF YIG filter\n")
    else:
        print("No IF filter specified\n")
        if_filter = None

    print("Remember to specify measurement parameters:")
    print("\t-device, njunc, icoil, freq, etc.\n")

    # for interactive plots...
    plt.ion()

    # Loop continuously for interactive environment
    while True:

        # Get next command
        command = input(">> ")
        command = command.split()
        if len(command) == 0:
            continue
        if not isinstance(command, list):
            command = [command, ]
        command[0] = command[0].upper()

        # Set parameters --------------------------------------------------- #

        # PARAMETERS
        if command[0] in param.keys() and command[0] not in ["FREQUENCY", "FREQ", "F", "IFFREQUENCY", "IFFREQ", "IF", "VCTRL", "V", "VBIAS", "VB"]:
            # Print parameter value
            if len(command) == 1:
                print(f"\n\t{command[0]} : {param[command[0]]}\n")
            # Set parameter value
            elif len(command) == 2:
                # String parameters
                if command[0].upper() in ["LNA", "DEVICE"]:
                    param[command[0].upper()] = command[1]
                # Float parameters
                else:
                    try:
                        param[command[0]] = float(command[1])
                    except ValueError:
                        print("\n\tError: Value must be int or float.\n")
            # Error
            else:
                print("\n\tError too many values provided for parameter.")

        # FREQ: Record LO frequency (no action)
        elif command[0] == "FREQ" or command[0] == "F":

            # Print help
            if len(command) == 2 and command[1].upper() == "H":
                print("\n\tSet LO frequency parameter (no action)\n")
                print("\tUseage: FREQ <freq>")
                print("\t        F <freq>")
                print("\twhere <freq> is the frequency in units [GHz]\n")
                continue

            if len(command) > 1:
                try:
                    param['FREQ'] = float(command[1])
                    if param['FREQ'] != 0:
                        print(f"\n\tSource frequency: {param['FREQ']/18:6.2f} GHz (x18)")
                        print(f"\tGunn frequency:   {param['FREQ']/3:6.2f} GHz (x3)")
                        print(f"\tLO frequency:     {param['FREQ']:6.2f} GHz\n")
                    else:
                        print("\n\tDC (no LO pumping)\n")
                except ValueError:
                    print("\n\tError: Frequency must be a float.\n")
            else:
                print(f"\n\tLO frequency: {param['FREQ']:.1f} GHz\n")

        # IFFREQ: Set IF frequency
        elif command[0] == "IFFREQ" or command[0] == "IF":

            # Print help
            if len(command) == 2 and command[1].upper() == "H":
                print("\n\tSet IF frequency\n")
                print("\tUseage: IFFREQ <freq>")
                print("\t        IF <freq>")
                print("\twhere <freq> is the frequency in units [GHz]\n")
                continue

            if len(command) > 1:
                try:
                    param['IFFREQ'] = float(command[1])
                    if_filter.set_frequency(param['IFFREQ'])
                except ValueError:
                    print("\n\tError: Frequency must be a float.\n")
            else:
                print(f"\n\tIF frequency: {param['IFFREQ']:.3f}\n")

        # VCTRL: Set control voltage (constant)
        elif command[0] == "V" or command[0] == "VCTRL":

            # Print help
            if len(command) == 2 and command[1].upper() == "H":
                print("\n\tSet control voltage\n")
                print("\tUseage: VCTRL <vcontrol>")
                print("\t        V <vcontrol>")
                print("\twhere <vcontrol> is the voltage in units [V]\n")
                continue

            if len(command) == 1:
                print(f"\n\tControl voltage: {param['VCTRL']:6.2f} V\n")
            else:
                param['VCTRL'] = float(command[1])
                print(f"\n\tControl voltage: {param['VCTRL']:6.2f} V")
                bias.set_control_voltage(param['VCTRL'], vlimit=param['VLIMIT'])
                time.sleep(0.1)
                vmon_mv = bias.read_voltage()
                print(f"\tVoltage monitor: {vmon_mv:6.2f} mV\n")
                imon_ua = bias.read_current()
                print(f"\tCurrent monitor: {imon_ua:6.2f} uA\n")

        # VBIAS: Set bias voltage (constant)
        elif command[0] == "VBIAS" or command[0] == "VB":

            # Print help
            if len(command) == 2 and command[1].upper() == "H":
                print("\n\tSet bias voltage\n")
                print("\tUseage: VBIAS <vbias> <iterations>")
                print("\t        VB <vbias> <iterations>")
                print("\twhere <vbias> is the voltage in units [mV] (default 0)")
                print("\t      <iterations> is the number of iterations (default 3)\n")
                continue

            # arg 1: target value
            try: 
                vbias = float(command[1])
            except (IndexError, ValueError) as e:
                vbias = 0 

            # arg 2: number of iterations
            try:
                iterations = int(command[2])
            except (IndexError, ValueError) as e:
                iterations = 3
            
            print(f"\n\tBias target:   {vbias:6.2f} mV\n")
            _, param['VCTRL'] = bias.set_bias_voltage(vbias, iterations=iterations, verbose=True, vlimit=param["VLIMIT"])

        # VBMIN: Set minimum bias voltage
        elif command[0] == "VBMIN":

            # Print help
            if len(command) == 2 and command[1].upper() == "H":
                print("\n\tSet minimum bias voltage\n")
                print("\tUseage: VBMIN <vbias>")
                print("\twhere <vbias> is the voltage in units [mV] (default 0)\n")
                continue

            # arg 1: target value
            try: 
                vbias = float(command[1])
                param['VMIN'] = vbias / 1000 * bias.config['VMON']['GAIN']
            except (IndexError, ValueError) as e:
                vbias = param['VMIN'] * 1000 / bias.config['VMON']['GAIN']

            print(f"\n\tBias voltage (min):    {vbias:.1f} mV")
            print(f"  \tControl voltage (min): {param['VMIN']:.1f} V\n")

        # VBMAX: Set maximum bias voltage
        elif command[0] == "VBMAX":

            # Print help
            if len(command) == 2 and command[1].upper() == "H":
                print("\n\tSet maximum bias voltage\n")
                print("\tUseage: VBMAX <vbias>")
                print("\twhere <vbias> is the voltage in units [mV] (default 0)\n")
                continue

            # arg 1: target value
            try: 
                vbias = float(command[1])
                param['VMAX'] = vbias / 1000 * bias.config['VMON']['GAIN']
            except (IndexError, ValueError) as e:
                vbias = param['VMAX'] * 1000 / bias.config['VMON']['GAIN']

            print(f"\n\tBias voltage (max):    {vbias:.1f} mV")
            print(f"  \tControl voltage (max): {param['VMAX']:.1f} V\n")

        # Calibration ------------------------------------------------------ #

        # CALIF: Calibrate IF power
        elif command[0] == "CALIF":

            # Print help
            if len(command) == 2 and command[1].upper() == "H":
                print("\n\tCalibrate IF power\n")
                print("\tUseage: CALIF <vbmin> <vbmax> <average>")
                print("\twhere <vbmin> is the minimum voltage for the shot noise slope, default is 12.5 mV")
                print("\t      <vbmax> is the maximum voltage for the shot noise slope, default is 15.0 mV")
                print("\t      <average> is the averaging, default is 1000\n")
                continue

            print("\n\tCALIBRATE IF POWER:")

            # arg 1: min bias voltage
            if len(command) > 1:
                vbmin = float(command[1])
            else:
                vbmin = param['VBMIN_LINEAR']

            # arg 2: max bias voltage
            if len(command) > 2:
                vbmax = float(command[2])
            else:
                vbmax = param['VBMAX_LINEAR']

            # arg 3: averaging
            if len(command) > 3:
                average = int(command[3])
            else:
                average = 10_000

            # Calculate IF power offset
            param["IFOFFSET"] = bias.calibrate_if_power_offset(average=average)

            # Calculate shot noise slope
            vmin = vbmin / 1000 * bias.config['VMON']['GAIN'] 
            vmax = vbmax / 1000 * bias.config['VMON']['GAIN'] 
            param["IFCORR"] = bias.calibrate_if_power(vmin=vmin, vmax=vmax, average=average, njunc=param["NJUNC"], extra=False, debug=True)

        # CALIV: Calibrate I-V data
        elif command[0] == "CALIV":

            # Print help
            if len(command) == 2 and command[1].upper() == "H":
                print("\n\tCalibrate I-V offset\n")
                print("\tUseage: CALIV <vbmin> <vbmax>")
                print("\twhere <vbmin> is the minimum voltage for the shot noise slope, default is 12.5 mV")
                print("\t      <vbmax> is the maximum voltage for the shot noise slope, default is 15.0 mV\n")
                continue

            print("\n\tCALIBRATE I-V OFFSET:")

            # arg 1: min bias voltage
            if len(command) > 1:
                vbmin = float(command[1])
            else:
                vbmin = param['VBMIN_LINEAR']

            # arg 2: max bias voltage
            if len(command) > 2:
                vbmax = float(command[2])
            else:
                vbmax = param['VBMAX_LINEAR']

            vmin = vbmin / 1000 * bias.config['VMON']['GAIN'] 
            vmax = vbmax / 1000 * bias.config['VMON']['GAIN'] 
            param["VOFFSET"] = bias.calibrate_voffset(debug=True)
            param["IOFFSET"] = bias.calibrate_ioffset(debug=True, vmin=vmin, vmax=vmax)

        # Read out single values (no sweep) -------------------------------- #

        # VMON: Read voltage monitor
        elif command[0] == "VMON":

            # Print help
            if len(command) == 2 and command[1].upper() == "H":
                print("\n\tMeasure voltage monitor\n")
                print("\tUseage: VMON <average>")
                print("\twhere <average> is the number of points to average (default is 2000)\n")
                continue

            # arg 1: number of points to average
            try:
                average = int(command[1])
            except (IndexError, ValueError) as e:
                average = 2_000

            _ = bias.read_voltage(average=average, verbose=True)

        # IMON: Read current monitor
        elif command[0] == "IMON":

            # Print help
            if len(command) == 2 and command[1].upper() == "H":
                print("\n\tMeasure current monitor\n")
                print("\tUseage: IMON <average>")
                print("\twhere <average> is the number of points to average (default is 2000)\n")
                continue

            # arg 1: number of points to average
            try:
                average = int(command[1])
            except (IndexError, ValueError) as e:
                average = 2_000

            _ = bias.read_current(average=average, verbose=True)

        # PIF: Read IF power
        elif command[0] == "PIF":

            # Print help
            if len(command) == 2 and command[1].upper() == "H":
                print("\n\tMeasure IF power\n")
                print("\tUseage: PIF <average>")
                print("\twhere <average> is the number of points to average (default is 2000)\n")
                continue

            # arg 1: number of points to average
            try:
                average = int(command[1])
            except (IndexError, ValueError) as e:
                average = 2_000

            _ = bias.read_ifpower(average=average, verbose=True)

        # VRAW: Read voltage monitor (raw)
        elif command[0] == "VRAW":

            # Print help
            if len(command) == 2 and command[1].upper() == "H":
                print("\n\tMeasure raw voltage monitor voltage\n")
                print("\tUseage: VRAW <average>")
                print("\twhere <average> is the number of points to average (default is 2000)\n")
                continue

            # arg 1: number of points to average
            try:
                average = int(command[1])
            except (IndexError, ValueError) as e:
                average = 2_000

            vraw_avg, vraw_std = bias.read_voltage(average=average, stats=True, raw=True)
            print(f"\n\tRaw voltage: {vraw_avg:.4f} +/- {vraw_std:.4f} V\n")

        # IRAW: Read current monitor (raw)
        elif command[0] == "IRAW":

            # Print help
            if len(command) == 2 and command[1].upper() == "H":
                print("\n\tMeasure raw current monitor voltage\n")
                print("\tUseage: IRAW <average>")
                print("\twhere <average> is the number of points to average (default is 2000)\n")
                continue

            # arg 1: number of points to average
            try:
                average = int(command[1])
            except (IndexError, ValueError) as e:
                average = 2_000

            iraw_avg, iraw_std = bias.read_current(average=average, stats=True, raw=True)
            print(f"\n\tRaw current: {iraw_avg:.4f} +/- {iraw_std:.4f} V\n")

        # READ: read monitors continuously
        elif command[0] == "READ":

            # Print help
            if len(command) == 2 and command[1].upper() == "H":
                print("\n\tMeasure voltage, current, IF power continuously\n")
                print("\tUseage: READ <average>")
                print("\twhere <average> is the number of points to average (default is 2000)\n")
                continue

            try:
                average = int(command[1])
            except (IndexError, ValueError) as e:
                average = 1000

            print("\n\tVoltage\t\tCurrent\t\tIF power\n")
            try:
                while True:
                    vmon_mv, imon_ua, ifpower_k = bias.read_all(average=average)
                    print(f"\t{vmon_mv:7.3f} mV\t{imon_ua:7.2f} uA\t{ifpower_k:7.4f} K")
            except KeyboardInterrupt:
                print("")
                plt.close('all')
                continue

        # Sweep control voltage -------------------------------------------- #

        # SWEEP: Sweep control voltage (triangle wave)
        elif command[0] == "SWEEP" or command[0] == "S":

            # Print help
            if len(command) == 2 and command[1].upper() == "H":
                print("\n\tSweep control voltage (triangular wave)\n")
                print("\tUseage: SWEEP")
                print("\t        S\n")
                continue

            print("\n\tSWEEP CONTROL VOLTAGE")
            bias.sweep_control_voltage(vmin=param['VMIN'],
                                       vmax=param['VMAX'],
                                       sweep_period=param['PERIOD'],
                                       npts=param['NPTS'],
                                       vlimit=param['VLIMIT'])
            bias.start_iv_monitor_scan(sweep_period=param['PERIOD'],
                                       npts=param['NPTS'])
            print("")

        # SQUARE: Sweep control voltage (square wave)
        elif command[0] == "SQUARE":

            # Print help
            if len(command) == 2 and command[1].upper() == "H":
                print("\n\tSweep control voltage (square wave)\n")
                print("\tUseage: SQUARE\n")
                continue

            print("\n\tPULSE CONTROL VOLTAGE")
            bias.pulse_control_voltage(vmin=param['VMIN'],
                                       vmax=param['VMAX'],
                                       sweep_period=param['PERIOD'],
                                       npts=param['NPTS'], 
                                       vlimit=param['VLIMIT'])
            bias.start_iv_monitor_scan(sweep_period=param['PERIOD'],
                                       npts=param['NPTS'])
            print("")

        # Measure IV / IF data --------------------------------------------- #

        # TUNE: Plot I-V curve for tuning purposes
        elif command[0] == "TUNE" or command[0] == "T":

            # Print help
            if len(command) == 2 and command[1].upper() == "H":
                print("\n\tPlot IV/IF curves for tuning purposes\n")
                print("\tUseage: TUNE")
                print("\t        T\n")
                continue

            print("\n\tTUNE LO POWER:")
            print("\n\t** Remember to wipe vacuum window **")

            # Quick first pass (to get limits)
            bias.sweep_control_voltage(vmin=param['VMIN'],
                                       vmax=param['VMAX'],
                                       sweep_period=1,
                                       npts=1000,
                                       vlimit=param['VLIMIT'])
            bias.start_iv_monitor_scan(npts=1000, sweep_period=1)
            time.sleep(2)
            print("")

            voltage, current, ifpower = bias.read_iv_curve_buffer()

            # Initialize figure
            fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 6))
            ax1.set_xlabel("Bias Voltage (mV)")
            ax2.set_xlabel("Bias Voltage (mV)")
            ax1.set_ylabel("Bias Current (uV)")
            ax2.set_ylabel("IF Power (au)")
            line1, = ax1.plot([0], [0], 'ko-', ms=3)
            line2, = ax2.plot([0], [0], 'ko-', ms=3)
            ax1.set_xlim([voltage.min(), voltage.max()])
            ax2.set_xlim([voltage.min(), voltage.max()])
            ax1.set_ylim([current.min(), current.max()])
            ax2.set_ylim([0, ifpower.max() * 2])
            fig.canvas.draw()
            plt.show()

            while True:
                try:
                    results = bias.measure_ivif(average=64, vmin=param['VMIN'], vmax=param['VMAX'], npts=20, vlimit=param['VLIMIT'], verbose=False)
                    if results is None:
                        break
                    v_results, _, i_results, _, p_results, _ = results

                    line1.set_data(v_results, i_results)
                    line2.set_data(v_results, p_results)
                    fig.canvas.draw()
                    plt.pause(0.0001)
                    fig.canvas.flush_events()

                except KeyboardInterrupt:
                    print("")
                    plt.close('all')
                    break

        # MONITOR: Real time plot of I-V curve
        elif command[0] == "MONITOR" or command[0] == "MON":

            # Print help
            if len(command) == 2 and command[1].upper() == "H":
                print("\n\tPlot I-V/IF data in real-time\n")
                print("\tUseage: MONITOR <npts> <period>")
                print("\t        MON <npts> <period>")
                print("\twhere <npts> is the number of points")
                print("\t      <period> is the sweep period\n")
                continue

            print("\n\tMONITOR:")

            if len(command) > 1:
                npts = float(command[1])
            else:
                npts = param['NPTS']

            if len(command) > 2:
                period = float(command[2])
            else:
                period = param['PERIOD']

            bias.monitor(npts=npts, period=period, vmin=param['VMIN'], vmax=param['VMAX'], vlimit=param['VLIMIT'])

        # MEASURE: Measure IV / IF curve
        elif command[0] == "MEASURE" or command[0] == "M":

            # Print help
            if len(command) == 2 and command[1].upper() == "H":
                print("\n\tMeasure I-V/IF curves (high-resolution)\n")
                print("\tUseage: MEASURE <npts> <average> <sleeptime>")
                print("\t        M <npts> <average> <sleeptime>")
                print("\twhere <npts> is the number of points (default 1001)")
                print("\t      <average> is the averaging (default 64)")
                print("\t      <sleeptime> is the sleep time between points (default 0.1)\n")
                continue

            print("\n\tMEASURE I-V + IF CURVE:")

            # arg 1: number of points
            if len(command) > 1:
                npts = int(command[1])
            else:
                npts = 1001

            # arg 2: averaging
            if len(command) > 2:
                average = int(command[2])
            else:
                average = 64

            # arg 3: sleep time
            if len(command) > 3:
                sleep_time = float(command[3])
            else:
                sleep_time = 0.1

            # Parameters
            vmin, vmax = param["VMIN"], param["VMAX"]
            vbmin = vmin * 1000 / bias.config['VMON']['GAIN']
            vbmax = vmax * 1000 / bias.config['VMON']['GAIN']
            vctrl_sweep = np.linspace(vmin, vmax, npts)
            print(f"\n\tControl voltage sweep: {vmin:5.1f} to {vmax:5.1f} V")
            print(f"  \tBias voltage sweep:    {vbmin:5.1f} to {vbmax:5.1f} mV\n")

            # Sweep bias voltage and measure voltage / current / IF power
            try:
                voltage = np.zeros(npts)
                current = np.zeros(npts)
                ifpower = np.zeros(npts)
                for i, _vctrl in np.ndenumerate(vctrl_sweep):
                    bias.set_control_voltage(_vctrl, vlimit=param['VLIMIT'])
                    time.sleep(sleep_time)
                    voltage[i], current[i], ifpower[i] = bias.read_all(average=average)
                    progress_bar(i[0] + 1, len(vctrl_sweep), prefix="\tProgress: ")
            except KeyboardInterrupt:
                print("")
                plt.close('all')
                continue

            # Sort by voltage
            idx = voltage.argsort()
            voltage, current, ifpower = voltage[idx], current[idx], ifpower[idx]

            # Find intercept, normal resistance and IF noise
            print(f"\n\tRange for linear fit:\t{param['VBMIN_LINEAR']:5.1f} to {param['VBMAX_LINEAR']:5.1f} mV")
            if param['FREQ'] == 0:
                mask = (param['VBMIN_LINEAR'] <= voltage) & (voltage <= param['VBMAX_LINEAR'])
                try:
                    pnormal = np.polyfit(voltage[mask], current[mask], 1)
                    v_intercept = -pnormal[1] / pnormal[0]
                    print(f"\n\tIntercept:\t\t{v_intercept:.3f} mV")
                    rnormal = 1000 / pnormal[0]
                    print(f"  \tNormal resistance:\t{rnormal:.1f} ohms")
                    pifnoise = np.polyfit(voltage[mask], ifpower[mask], 1)
                    if_noise = np.polyval(pifnoise, v_intercept)
                    gamma = (50 - rnormal) / (50 + rnormal)
                    gmismatch = 1 - np.abs(gamma) ** 2
                    if_noise_corr = (if_noise - 1.3) * gmismatch
                    print(f"  \tIF noise:\t\t{if_noise:.1f} K")
                    print(f"  \t         \t\t{if_noise_corr:.1f} K (after correction)")
                    print(f"  \tMean IF power:\t\t{np.mean(ifpower):.1f} K\n")
                except:
                    pnormal = None
                    pifnoise = None
                    v_intercept = None 
                    rnormal = None 
                    if_noise = None
                    if_noise_corr = None
                    pass

            # Plot I-V curve
            fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12,5))
            ax1.plot(voltage, current, 'k-', label='I-V curve')
            if vmin == -vmax:
                ax1.plot(-voltage, -current, 'k-', alpha=0.5)
            if param['FREQ'] == 0:
                if pnormal is not None:
                    ax1.plot(voltage[voltage > 0], np.polyval(pnormal, voltage[voltage > 0]), 'r-', lw=0.5, label=r"$R_n={:.1f}~\Omega$".format(rnormal))
                if v_intercept is not None:
                    ax1.plot(v_intercept, 0, 'r*', ms=10, label="$x$-intercept")
            ax1.set_xlabel("Voltage (mV)")
            ax1.set_ylabel("Current (uA)")
            ax1.legend(loc=2, frameon=True)

            # Plot IF power
            ax2.plot(voltage, ifpower, 'k-', label='IF power')
            if vmin == -vmax:
                ax2.plot(-voltage, ifpower, 'k-', alpha=0.5)
            if param['FREQ'] == 0:
                if pifnoise is not None:
                    ax2.plot(voltage, np.polyval(pifnoise, voltage), 'r-', lw=0.5)
                    tif_str = r"$T_\mathrm{IF}$"
                if v_intercept is not None and if_noise is not None:
                    ax2.plot(v_intercept, if_noise, 'r*', ms=10, label="{}: {:.1f} K".format(tif_str, if_noise))
                    tif_str = r"$T_\mathrm{IF}^\prime$"
                if if_noise_corr is not None:
                    ax2.plot(v_intercept, if_noise_corr, 'b*', ms=10, label="{}: {:.1f} K".format(tif_str, if_noise_corr))
            ax2.legend(loc=4, frameon=True)
            ax2.set_ylabel("IF Power (K)")
            ax2.set_xlabel("Voltage (mV)")
            ax2.set_ylim(ymin=0)
            plt.show()

            filename = ask_filename()
            if filename is None:
                print("\n\tNot any saving data.\n")
            else:
                # Save data
                header = "Voltage (mV), Current (uA), IF power (K)"
                np.savetxt(filename + ".dat", np.vstack((voltage, current, ifpower)).T, header=header)
                # Save metadata
                with open(filename + ".mdat", "w") as fout:
                    json.dump(param, fout, indent=4)

        # YFAC: Measure Y-factor
        elif command[0] == "YFAC" or command[0] == "Y":

            # Print help
            if len(command) == 2 and command[1].upper() == "H":
                print("\n\tMeasure Y-factor (high-resolution)\n")
                print("\tUseage: YFAC <npts> <average> <sleeptime>")
                print("\t        Y <npts> <average> <sleeptime>")
                print("\twhere <npts> is the number of points (default 201)")
                print("\t      <average> is the averaging (default 64)")
                print("\t      <sleeptime> is the sleep time between points (default 0.1)\n")
                continue

            print("\n\tMEASURE Y-FACTOR:")

            # arg 1: number of points
            if len(command) > 1:
                npts = int(command[1])
            else:
                npts = 201

            # arg 2: averaging
            if len(command) > 2:
                average = int(command[2])
            else:
                average = 64

            # arg 3: sleep time
            if len(command) > 3:
                sleep_time = float(command[3])
            else:
                sleep_time = 0.1

            # Parameters
            vmin, vmax, vlimit = param["VMIN"], param["VMAX"], param["VLIMIT"]
            vbmin, vbmax = vmin * 1000 / bias.config['VMON']['GAIN'], vmax * 1000 / bias.config['VMON']['GAIN']
            print(f"\n\tControl voltage sweep: {vmin:4.1f} to {vmax:4.1f} V")
            print(f"  \tBias voltage sweep:    {vbmin:4.1f} to {vbmax:4.1f} mV\n")
            print(f"\tNumber of points: {npts}")
            print(f"\tAveraging: {average}")
            print(f"\tSleep time: {sleep_time:.1f} s\n")

            # Start with hot load
            bias.hot_load()
            time.sleep(1)
            vh, ih, ph = bias.measure_ivif(npts=npts, vmin=vmin, vmax=vmax, vlimit=vlimit, sleep_time=sleep_time, average=average, stats=False, msg="\tHot load:  ")

            # Switch to cold load
            bias.cold_load()
            time.sleep(1)
            vc, ic, pc = bias.measure_ivif(npts=npts, vmin=vmin, vmax=vmax, vlimit=vlimit, sleep_time=sleep_time, average=average, stats=False, msg="\tCold load: ")

            # Interpolate to common voltage
            vb_min = max(vh.min(), vc.min())
            vb_max = min(vh.max(), vc.max())
            v = np.linspace(vb_min, vb_max, npts)
            ih = np.interp(v, vh, ih)
            ic = np.interp(v, vc, ic)
            ph = np.interp(v, vh, ph)
            pc = np.interp(v, vc, pc)
            vh, vc = v.copy(), v.copy()

            # Calculate noise temperature
            yfac = ph / pc
            tn = (293 - yfac * 78) / (yfac - 1)
            tn[tn < 0] = 1e10
            gain = (ph - pc) / (293 - 78)

            # Plot I-V curve
            fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12,5))
            ax3 = ax2.twinx()
            ax1.plot(v, ih, 'r', label='Hot')
            ax1.plot(v, ic, 'b', label='Cold')
            ax1.set_xlabel("Voltage (mV)")
            ax1.set_ylabel("Current (uA)")
            ax1.legend(loc=2, frameon=True)

            # Plot IF power
            ax2.plot(v, ph, 'r', label='Hot')
            ax2.plot(v, pc, 'b', label='Cold')
            ax3.plot(v, tn, 'g', label=r"$T_n$")
            ax3.set_ylabel("Noise Temperature (K)")
            ax2.set_ylabel("IF Power (K)")
            ax2.set_xlabel("Voltage (mV)")
            ax2.legend(loc=2, frameon=True)
            ax3.legend(loc=1, frameon=True)
            ax3.set_ylim([0, 150])
            ax2.set_ylim(ymin=0)
            plt.show()

            filename = ask_filename()
            if filename is None:
                print("\tNot any saving data.\n")
            else:
                # Save data
                header = "Voltage (mV), Hot Current (uA), Cold Current (uA), Hot IF power (K), Cold IF power (K), Noise Temperature (K), Gain"
                np.savetxt(filename + ".dat", np.vstack((v, ih, ic, ph, pc, tn, gain)).T, header=header)
                fig.savefig(filename + ".png", dpi=600)
                # Save metadata
                with open(filename + ".mdat", "w") as fout:
                    json.dump(param, fout, indent=4)

        # MEASUREIF: Measure IF power vs IF frequency
        elif command[0] == "MEASUREIF" or command[0] == "MIF":

            # Print help
            if len(command) == 2 and command[1].upper() == "H":
                print("\n\tMeasure IF power versus IF frequency\n")
                print("\tUseage: MEASUREIF <start> <stop> <step> <average>")
                print("\t        MIF <start> <stop> <step> <average>")
                print("\twhere <start> is the start frequency, in units GHz (default 3)")
                print("\t      <stop> is the stop frequency, in units GHz (default 25)")
                print("\t      <step> is the frequency step, in units GHz (default 0.1)")
                print("\t      <average> is the number of points to average (default 100)\n")
                continue

            print("\n\tMEASURE IF POWER VS IF FREQUENCY:\n")

            # arg 1: start
            if len(command) > 1:
                start = float(command[1])
            else:
                start = 3.0

            # arg 2: stop
            if len(command) > 2:
                stop = float(command[2])
            else:
                stop = 25.0

            # arg 3: step
            if len(command) > 3:
                step = float(command[3])
            else:
                step = 0.1

            # arg 4: average
            if len(command) > 4:
                average = float(command[3])
            else:
                average = 100

            # Measure IF power
            try:
                if_frequency = np.arange(start, stop+1e-10, step)
                if_power = np.empty_like(if_frequency)
                if_power_std = np.empty_like(if_frequency)
                for i, _if_freq in np.ndenumerate(if_frequency):
                    if_filter.set_frequency(_if_freq)
                    time.sleep(0.1)
                    if_power_avg, if_power_std[i] = bias.read_ifpower(average=average, stats=True)
                    if_power[i] = if_power_avg #- param["IFOFFSET"]
                    progress_bar(i[0] + 1, len(if_frequency), prefix="\tProgress: ")
            except KeyboardInterrupt:
                print("")
                plt.close('all')
                continue

            # Return to previous IF frequency
            if_filter.set_frequency(param['IFFREQ'])

            # Plot
            plt.figure(figsize=(6,5))
            plt.plot(if_frequency, if_power)
            plt.fill_between(if_frequency, if_power - if_power_std, if_power + if_power_std, alpha=0.2)
            plt.xlabel("IF frequency (GHZ)")
            plt.ylabel("IF power (K)")
            plt.show()

            # Save data
            filename = ask_filename()
            if filename is None:
                print("\tNot any saving data.\n")
            else:
                # Save data
                header = "IF frequency (GHz), IF power (K), IF std dev (K)"
                np.savetxt(filename + ".dat", np.vstack((if_frequency, if_power, if_power_std)).T, header=header)
                # Save metadata
                with open(filename + ".mdat", "w") as fout:
                    json.dump(param, fout, indent=4)

        # CONST: Set constant bias and monitor V + I
        elif command[0] == "CONST":

            # Print help
            if len(command) == 2 and command[1].upper() == "H":
                print("\n\tSet constant control voltage and measure statistics\n")
                print("\tUseage: CONST <vcontrol> <npts>")
                print("\twhere <vcontrol> is the control voltage, in units [V]")
                print("\t      <npts> is the number of sample points (default is 50,000)\n")
                continue

            print("\n\tCONSTANT CONTROL VOLTAGE:\n")

            # arg 1: control voltage
            if len(command) > 1:
                param['VCTRL'] = float(command[1])

            # arg 2: number of sample points
            if len(command) > 2:
                npts = int(command[2])
            else:
                npts = 50_000

            bias.noise_statistics(vcontrol=param['VCTRL'], npts=npts, vlimit=param["VLIMIT"])

        # RESISTANCE: Fit resistance of I-V curve
        elif command[0] == "RESISTANCE" or command[0] == "R":

            # Print help
            if len(command) == 2 and command[1].upper() == "H":
                print("\n\tMeasure the resistance of the I-V curve\n")
                print("\tUseage: RESISTANCE")
                print("\t        R\n")
                continue

            voltage, current, _ = bias.read_iv_curve_buffer()
            voltage *= 1e-3
            current *= 1e-6
            idx = current.argsort()
            voltage = voltage[idx]
            current = current[idx]
            p, cov = np.polyfit(current, voltage, 1, cov=True)
            perr = np.sqrt(np.diag(cov))
            print(f"\n\tResistance: {p[0]:.2f} +/- {perr[0]:.2f} ohms\n")

        # Digital input/output --------------------------------------------- #

        # HOT: move load to hot position
        elif command[0] == "HOT":

            # Print help
            if len(command) == 2 and command[1].upper() == "H":
                print("\n\tSet load to hot position\n")
                print("\tUseage: HOT\n")
                continue

            bias.hot_load()

        # COLD: move load to cold position
        elif command[0] == "COLD":

            # Print help
            if len(command) == 2 and command[1].upper() == "H":
                print("\n\tSet load to cold position\n")
                print("\tUseage: COLD\n")
                continue

            bias.cold_load()

        # Misc functions --------------------------------------------------- #

        # HELP: Print help for most useful commands
        # TODO: add new commands, vbmin, vbmax
        elif command[0] == "HELP" or command[0] == "H":

            print("\n\tMost useful commands/parameters:\n")
            print("\tVMIN <value>:\tMinimum voltage for sweep, in units [V]")
            print("\tVMAX <value>:\tMaximum voltage for sweep, in units [V]\n")
            print("\tV <value>:   \tSet control voltage to constant value, units [V]")
            print("\tVB <value>:  \tSet bias voltage to constant value, units [mV]\n")
            print("\tVMON:        \tRead the voltage monitor")
            print("\tIMON:        \tRead the current monitor")
            print("\tPIF:         \tRead the IF power\n")
            print("\tM:           \tMeasure IV/IF curves")
            print("\tMIF:         \tMeasure power versus IF frequency")
            print("\tMON:         \tPlot IV/IF curves in real-time\n")
            print("\tC:           \tClear all plots")
            print("\tQ:           \tExit application\n")
            print("\tFor all of these commands, you can enter 'H' for more help")
            print("\t(e.g., 'M H').\n")

        # ID: Print DAQ ID nubmer
        elif command[0] == "ID":

            # Print help
            if len(command) == 2 and command[1].upper() == "H":
                print("\n\tPrint ID of DAQ unit\n")
                print("\tUseage: ID\n")
                continue

            print("\n\t", bias, "\n")

        # INFO: Print all parameters
        elif command[0] == "INFO":

            # Print help
            if len(command) == 2 and command[1].upper() == "H":
                print("\n\tPrint all parameters\n")
                print("\tUseage: INFO\n")
                continue

            print("")
            for key, value in param.items():
                if isinstance(value, int) or isinstance(value, float):
                    print(f"\t{key:15s}{value:.1f}")
                else:
                    print(f"\t{key:15s}{value}")
            print("")

        # CLEAR: Clear all plots
        elif command[0] == "CLEAR" or command[0] == "C":

            # Print help
            if len(command) == 2 and command[1].upper() == "H":
                print("\n\tClear all plots\n")
                print("\tUseage: CLEAR")
                print("\t        C\n")
                continue

            plt.close("all")

        # EXIT: Stop bias and shutdown
        elif command[0] == "EXIT" or command[0] == "Q":

            # Print help
            if len(command) == 2 and command[1].upper() == "H":
                print("\n\tStop bias and shutdown\n")
                print("\tUseage: EXIT")
                print("\t        Q\n")
                continue

            break

        # Command not recognized...
        else:
            print("\n\tCommand not recognized.\n")

except KeyboardInterrupt:
    print("\nClosing program.")

except EOFError:
    print("\nClosing program.")

except uldaq.ul_exception.ULException:
    print("\nConnection lost to device.")

except RuntimeError:
    bias = None

finally:
    
    if bias is not None:

        # Save parameters to file (for persistence)
        with open(param_filename, 'w') as fout:
            json.dump(param, fout, indent=4)
        print(f"\nMeasurement parameters saved to: {param_filename}")
        bias.save_cal()
        bias.save_config()
        print("")

    try:
        bias.set_control_voltage(0, verbose=True)
        bias.close()
    except (NameError, AttributeError, uldaq.ul_exception.ULException) as e:
        pass
