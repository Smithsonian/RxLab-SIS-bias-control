#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""Interactive script for controlling the SIS bias."""

import argparse
import json
import time
import numpy as np
import matplotlib.pyplot as plt 
import os.path

from appdirs import user_config_dir

from sisbias import SISBias, progress_bar, ask_filename
from sisbias.filters import gauss_conv
from labinstruments.microlambda import YigFilter

try:
    plt.style.use(["science", "sans", "no-latex"])
except ModuleNotFoundError:
    print("Matplotlib styles not found")
    print("\ttry: pip install SciencePlots")
except OSError:
    print("Matplot styles not found")
    print("\ttry: pip install SciencePlots")

# ----------------------------------------------------------------------------

# Grab arguments
parser = argparse.ArgumentParser(description="Plot I-V curve and IF power in realtime.")
parser.add_argument("-c", "--configfile", type=str, help="Configuration file", default=None)
parser.add_argument("-p", "--paramfile", type=str, help="Parameter file", default=None)
parser.add_argument("--filteraddr", type=str, help="YIG filter IP address", default=None)  #"192.168.1.15")
args = parser.parse_args()

# Location of configuration file
if args.configfile is None:
    config_filename = user_config_dir("rxlab-sis-bias.config")
else:
    config_filename = args.configfile

# Read parameter file
if args.paramfile is None:
    param_filename = user_config_dir("rxlab-sis-bias.param")
else:
    param_filename = args.paramfile
with open(param_filename) as _fin:
    param = json.load(_fin)

# ----------------------------------------------------------------------------

try:
    # Initialize bias control
    bias = SISBias(config_file=config_filename)

    # Set bias voltage to zero
    param['VCTRL'] = 0
    bias.set_control_voltage(param['VCTRL'])

    # Save voltage / current gain to param (from config file)
    param["VMONGAIN"] = bias.config['VMON']['GAIN']
    param["IMONGAIN"] = bias.config['IMON']['GAIN']
    param["VMONOFFSET"] = bias.config['VMON']['OFFSET']
    param["IMONOFFSET"] = bias.config['IMON']['OFFSET']

    # Connect to IF filter
    if args.filteraddr is not None:
        if_filter = YigFilter(args.filteraddr)
        if_filter.set_frequency(param['IFFREQ'])
        print("Connected to IF YIG filter\n")
    else:
        print("No IF filter specified\n")
        if_filter = None

    print("Remember to specify measurement parameters:")
    print("\t-device, njunc, icoil, freq, etc.\n")

    # for interactive plots...
    plt.ion()

    # Loop continuously for interactive environment
    while True:

        # Get next command
        command = input(">> ")
        command = command.split()
        if len(command) == 0:
            continue
        if not isinstance(command, list):
            command = [command, ]
        command[0] = command[0].upper()

        # Set parameters --------------------------------------------------- #

        # PARAMETERS
        if command[0] in param.keys() and command[0] not in ["FREQUENCY", "FREQ", "F", "IFFREQUENCY", "IFFREQ", "IF", "VCTRL", "V", "VBIAS", "VB"]:
            # Print parameter value
            if len(command) == 1:
                print(f"\n\t{command[0]} : {param[command[0]]}\n")
            # Set parameter value
            elif len(command) == 2:
                # String parameters
                if command[0].upper() in ["LNA", "DEVICE"]:
                    param[command[0].upper()] = command[1]
                # Float parameters
                else:
                    try:
                        param[command[0]] = float(command[1])
                    except ValueError:
                        print("\n\tError: Value must be int or float.\n")
            # Error
            else:
                print("\n\tError too many values provided for parameter.")

        # FREQ: Record LO frequency (no action)
        elif command[0] == "FREQ" or command[0] == "F":

            # Print help
            if len(command) == 2 and command[1].upper() == "H":
                print("\n\tSet LO frequency parameter (no action)\n")
                print("\tUseage: FREQ <freq>")
                print("\t        F <freq>")
                print("\twhere <freq> is the frequency in units [GHz]\n")
                continue

            if len(command) > 1:
                try:
                    param['FREQ'] = float(command[1])
                    if param['FREQ'] != 0:
                        print(f"\n\tSource frequency: {param['FREQ']/18:6.2f} GHz (x18)")
                        print(f"\tGunn frequency:   {param['FREQ']/3:6.2f} GHz (x3)")
                        print(f"\tLO frequency:     {param['FREQ']:6.2f} GHz\n")
                    else:
                        print("\n\tDC (no LO pumping)\n")
                except ValueError:
                    print("\n\tError: Frequency must be a float.\n")
            else:
                print(f"\n\tLO frequency: {param['FREQ']:.1f} GHz\n")

        # IFFREQ: Set IF frequency
        elif command[0] == "IFFREQ" or command[0] == "IF":

            # Print help
            if len(command) == 2 and command[1].upper() == "H":
                print("\n\tSet IF frequency\n")
                print("\tUseage: IFFREQ <freq>")
                print("\t        IF <freq>")
                print("\twhere <freq> is the frequency in units [GHz]\n")
                continue

            if len(command) > 1:
                try:
                    if_filter.set_frequency(float(command[1]))
                    param['IFFREQ'] = float(command[1])
                except ValueError:
                    print("\n\tError: Frequency must be a float.\n")
            else:
                print(f"\n\tIF frequency: {param['IFFREQ']:.3f}\n")

        # VCTRL: Set control voltage (constant)
        elif command[0] == "V" or command[0] == "VCTRL":

            # Print help
            if len(command) == 2 and command[1].upper() == "H":
                print("\n\tSet control voltage\n")
                print("\tUseage: VCTRL <vcontrol>")
                print("\t        V <vcontrol>")
                print("\twhere <vcontrol> is the voltage in units [V]\n")
                continue

            if len(command) == 1:
                print("\n\tControl voltage: {:6.2f} V\n".format(param['VCTRL']))
            else:
                param['VCTRL'] = float(command[1])
                print("\n\tControl voltage: {:6.2f} V".format(param['VCTRL']))
                bias.set_control_voltage(param['VCTRL'], vmax=param['VLIMIT'])
                time.sleep(0.1)
                vmon_mv = bias.read_voltage()
                print("\tVoltage monitor: {:6.2f} mV\n".format(vmon_mv))
                imon_ua = bias.read_current() - param['IOFFSET']
                print("\tCurrent monitor: {:6.2f} uA\n".format(imon_ua))

        # VBIAS: Set bias voltage (constant)
        elif command[0] == "VBIAS" or command[0] == "VB":

            # Print help
            if len(command) == 2 and command[1].upper() == "H":
                print("\n\tSet bias voltage\n")
                print("\tUseage: VBIAS <vbias> <iterations>")
                print("\t        VB <vbias> <iterations>")
                print("\twhere <vbias> is the voltage in units [mV]")
                print("\t      <iterations> is the number of iterations\n")
                continue

            # arg 1: 
            try: 
                vbias = float(command[1])
            except:
                vbias = 0 

            # arg 2:
            try:
                iterations = int(command[2])
            except:
                iterations = 5
            
            print("\n\tBias target:   {:6.2f} mV\n".format(vbias))
            _, param['VCTRL'] = bias.set_bias_voltage(vbias, iterations=iterations, verbose=True, vmax=param["VLIMIT"])

        # Read out single values (no sweep) -------------------------------- #

        # VMON: Read voltage monitor
        elif command[0] == "VMON":

            # Print help
            if len(command) == 2 and command[1].upper() == "H":
                print("\n\tMeasure voltage monitor\n")
                print("\tUseage: VMON <average>")
                print("\twhere <average> is the number of points to average (default is 2000)\n")
                continue

            # arg 1: number of points to average
            try:
                average = int(command[1])
            except:
                average = 2_000

            vmon_mv = np.zeros(average)
            for i in range(average):
                vmon_mv[i] = bias.read_voltage()
            vmon_avg = np.mean(vmon_mv)
            vmon_std = np.std(vmon_mv)
            print(f"\n\tVoltage monitor: {vmon_avg:.3f} +/- {vmon_std:.3f} mV\n")

        # IMON: Read current monitor
        elif command[0] == "IMON":

            # Print help
            if len(command) == 2 and command[1].upper() == "H":
                print("\n\tMeasure current monitor\n")
                print("\tUseage: IMON <average>")
                print("\twhere <average> is the number of points to average (default is 2000)\n")
                continue

            # arg 1: number of points to average
            try:
                average = int(command[1])
            except:
                average = 2_000

            imon_ua = np.zeros(average)
            for i in range(average):
                imon_ua[i] = bias.read_current()
            imon_avg = np.mean(imon_ua) - param['IOFFSET']
            imon_std = np.std(imon_ua)
            print(f"\n\tCurrent monitor: {imon_avg:.3f} +/- {imon_std:.3f} uA\n")

        # VRAW: Read voltage monitor (raw)
        elif command[0] == "VRAW":

            # Print help
            if len(command) == 2 and command[1].upper() == "H":
                print("\n\tMeasure raw voltage monitor voltage\n")
                print("\tUseage: VRAW <average>")
                print("\twhere <average> is the number of points to average (default is 2000)\n")
                continue

            # arg 1: number of points to average
            try:
                average = int(command[1])
            except:
                average = 2_000

            vraw = np.zeros(average)
            for i in range(average):
                vraw[i] = bias.read_voltage(raw=True)
            vraw_avg = np.mean(vraw)
            vraw_std = np.std(vraw)
            print(f"\n\tRaw voltage: {vraw_avg:.4f} +/- {vraw_std:.4f} V\n")

        # IRAW: Read current monitor (raw)
        elif command[0] == "IRAW":

            # Print help
            if len(command) == 2 and command[1].upper() == "H":
                print("\n\tMeasure raw current monitor voltage\n")
                print("\tUseage: IRAW <average>")
                print("\twhere <average> is the number of points to average (default is 2000)\n")
                continue

            # arg 1: number of points to average
            try:
                average = int(command[1])
            except:
                average = 2_000

            iraw = np.zeros(average)
            for i in range(average):
                iraw[i] = bias.read_current(raw=True)
            iraw_avg = np.mean(iraw)
            iraw_std = np.std(iraw)
            print(f"\n\tRaw current: {iraw_avg:.4f} +/- {iraw_std:.4f} V\n")

        # PIF: Read IF power
        elif command[0] == "PIF":

            # Print help
            if len(command) == 2 and command[1].upper() == "H":
                print("\n\tMeasure IF power\n")
                print("\tUseage: PIF <average>")
                print("\twhere <average> is the number of points to average (default is 2000)\n")
                continue

            # arg 1: number of points to average
            try:
                average = int(command[1])
            except:
                average = 2_000

            ifpower_uw = np.zeros(average)
            for i in range(average):
                ifpower_uw[i] = bias.read_ifpower()
            ifpower_avg = np.mean(ifpower_uw)
            ifpower_avg_cal = ifpower_avg - param["IFOFFSET"]
            print("\n\tIF power: {:.4f} uW".format(ifpower_avg_cal))
            print("  \t          {:.4f} uW (prior to calibration)".format(ifpower_avg))
            print("  \t          {:.4f} K\n".format(ifpower_avg * param['IFCORR']))

        # READ: read monitors continuously
        elif command[0] == "READ":

            # Print help
            if len(command) == 2 and command[1].upper() == "H":
                print("\n\tMeasure voltage, current, IF power continuously\n")
                print("\tUseage: READ <average>")
                print("\twhere <average> is the number of points to average (default is 2000)\n")
                continue

            try:
                average = int(command[1])
            except:
                average = 1000

            print("\n\tVoltage\t\tCurrent\t\tIF power\n")
            try:
                while True:
                    vmon_mv = np.zeros(average)
                    for i in range(average):
                        vmon_mv[i] = bias.read_voltage()
                    vmon_mv = np.mean(vmon_mv)
                    imon_ua = np.zeros(average)
                    for i in range(average):
                        imon_ua[i] = bias.read_current()
                    imon_ua = np.mean(imon_ua)
                    ifpower_uw = np.zeros(average)
                    for i in range(average):
                        ifpower_uw[i] = bias.read_ifpower()
                    ifpower_uw = np.mean(ifpower_uw)
                    print(f"\t{vmon_mv:7.3f} mV\t{imon_ua:7.2f} uA\t{ifpower_uw:7.4f} AU")
            except KeyboardInterrupt:
                print("")
                plt.close('all')
                continue  # TODO

        # Sweep control voltage -------------------------------------------- #

        # SWEEP: Sweep control voltage (triangle wave)
        elif command[0] == "SWEEP" or command[0] == "S":

            # Print help
            if len(command) == 2 and command[1].upper() == "H":
                print("\n\tSweep control voltage (triangular wave)\n")
                print("\tUseage: SWEEP")
                print("\t        S\n")
                continue

            print("\n\tSWEEP CONTROL VOLTAGE")
            bias.sweep_control_voltage(vmin=param['VMIN'],
                                       vmax=param['VMAX'],
                                       sweep_period=param['PERIOD'],
                                       npts=param['NPTS'],
                                       vlimit=param['VLIMIT'])
            bias.start_iv_monitor_scan(sweep_period=param['PERIOD'],
                                       npts=param['NPTS'])
            print("")

        # SQUARE: Sweep control voltage (square wave)
        elif command[0] == "SQUARE":

            # Print help
            if len(command) == 2 and command[1].upper() == "H":
                print("\n\tSweep control voltage (square wave)\n")
                print("\tUseage: SQUARE\n")
                continue

            print("\n\tPULSE CONTROL VOLTAGE")
            bias.pulse_control_voltage(vmin=param['VMIN'],
                                       vmax=param['VMAX'],
                                       sweep_period=param['PERIOD'],
                                       npts=param['NPTS'], 
                                       vlimit=param['VLIMIT'])
            bias.start_iv_monitor_scan(sweep_period=param['PERIOD'],
                                       npts=param['NPTS'])
            print("")

        # Measure IV / IF data --------------------------------------------- #

        # TUNE: Plot I-V curve for tuning purposes
        elif command[0] == "TUNE" or command[0] == "T":

            # Print help
            if len(command) == 2 and command[1].upper() == "H":
                print("\n\tPlot IV/IF curves for tuning purposes\n")
                print("\tUseage: TUNE")
                print("\t        T\n")
                continue

            print("\n\tTUNE LO POWER:")
            print("\n\t** Remember to wipe vacuum window **")

            # Quick first pass (to get limits)
            bias.sweep_control_voltage(vmin=param['VMIN'],
                                       vmax=param['VMAX'],
                                       sweep_period=1,
                                       npts=1000,
                                       vlimit=param['VLIMIT'])
            bias.start_iv_monitor_scan(npts=1000, sweep_period=1)
            time.sleep(2)
            print("")

            voltage, current, ifpower = bias.read_iv_curve()
            current -= param['IOFFSET'] * 1e-6
            ifpower -= param['IFOFFSET']

            # Initialize figure
            fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 6))
            ax1.set_xlabel("Bias Voltage (mV)")
            ax2.set_xlabel("Bias Voltage (mV)")
            ax1.set_ylabel("Bias Current (uV)")
            ax2.set_ylabel("IF Power (au)")
            line1, = ax1.plot([0], [0], 'ko-', ms=3)
            line2, = ax2.plot([0], [0], 'ko-', ms=3)
            ax1.set_xlim([voltage.min() * 1e3, voltage.max() * 1e3])
            ax2.set_xlim([voltage.min() * 1e3, voltage.max() * 1e3])
            ax1.set_ylim([0, current.max() * 1e6])
            ax2.set_ylim([0, ifpower.max() * 2])
            fig.canvas.draw()
            plt.show()

            while True:
                try:
                    vctrl_sweep = np.linspace(param['VMIN'], param['VMAX'], 20)
                    v_results = np.zeros_like(vctrl_sweep)
                    i_results = np.zeros_like(vctrl_sweep)
                    p_results = np.zeros_like(vctrl_sweep)
                    for i, _vctrl in np.ndenumerate(vctrl_sweep):
                        bias.set_control_voltage(_vctrl, vmax=param['VLIMIT'])
                        time.sleep(0.1)
                        n_avg = 64
                        v_tmp, i_tmp, p_tmp = np.zeros(n_avg), np.zeros(n_avg), np.zeros(n_avg)
                        for j in range(n_avg):
                            v_tmp[j] = bias.read_voltage()
                            i_tmp[j] = bias.read_current()
                            p_tmp[j] = bias.read_ifpower()
                        v_results[i] = np.mean(v_tmp)
                        i_results[i] = np.mean(i_tmp)
                        p_results[i] = np.mean(p_tmp)

                    i_results -= param['IOFFSET']
                    p_results -= param['IFOFFSET']

                    line1.set_data(v_results, i_results)
                    line2.set_data(v_results, p_results)
                    fig.canvas.draw()
                    plt.pause(0.0001)
                    fig.canvas.flush_events()

                except KeyboardInterrupt:
                    print("")
                    plt.close('all')
                    break

        # MONITOR: Real time plot of I-V curve
        elif command[0] == "MONITOR" or command[0] == "MON":

            # Print help
            if len(command) == 2 and command[1].upper() == "H":
                print("\n\tPlot I-V/IF data in real-time\n")
                print("\tUseage: MONITOR <npts> <period>")
                print("\t        MON <npts> <period>")
                print("\twhere <npts> is the number of points")
                print("\t      <period> is the sweep period\n")
                continue

            print("\n\tMONITOR:")

            if len(command) > 1:
                npts = float(command[1])
            else:
                npts = param['NPTS']

            if len(command) > 2:
                period = float(command[2])
            else:
                period = param['PERIOD']

            # Start I-V bias sweeps
            bias.sweep_control_voltage(param['VMIN'], param['VMAX'], npts=npts, sweep_period=period, vlimit=param['VLIMIT'])
            bias.start_iv_monitor_scan(npts=npts, sweep_period=period)
            time.sleep(period * 2)
            print("")

            # Read I-V curve
            voltage, current, ifpower = bias.read_iv_curve()
            current -= param['IOFFSET'] * 1e-6
            ifpower -= param['IFOFFSET']

            # Create figure
            plt.ion()
            fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5))
            ax1.set_xlabel("Voltage (mV)")
            ax2.set_xlabel("Voltage (mV)")
            ax1.set_ylabel("Current (uA)")
            ax2.set_ylabel("IF power (uW)")
            ax1.set_xlim([voltage.min() * 1e3, voltage.max() * 1e3])
            ax2.set_xlim([voltage.min() * 1e3, voltage.max() * 1e3])
            ax1.set_ylim([current.min() * 1e6, current.max() * 1e6])
            ax2.set_ylim([0, ifpower.max() * 2])
            line1, = ax1.plot([0], [0], 'k.', ms=1)
            line2, = ax2.plot([0], [0], 'k.', ms=1)
            fig.canvas.draw()
            plt.show()

            while True:
                try:
                    # Restart scans
                    bias.sweep_control_voltage(param['VMIN'], param['VMAX'], npts=npts, sweep_period=period, verbose=False, vlimit=param['VLIMIT'])
                    bias.start_iv_monitor_scan(npts=npts, sweep_period=period, verbose=False)
                    time.sleep(period)

                    # Read I-V curve
                    voltage, current, ifpower = bias.read_iv_curve()
                    current -= param['IOFFSET'] * 1e-6
                    ifpower -= param['IFOFFSET']

                    # Draw I-V curve
                    line1.set_data(voltage * 1e3, current * 1e6)
                    line2.set_data(voltage * 1e3, ifpower)
                    fig.canvas.draw()
                    plt.pause(0.0001)
                    fig.canvas.flush_events()

                except KeyboardInterrupt:
                    print("")
                    plt.close('all')
                    break

        # MEASURE: Measure IV / IF curve
        elif command[0] == "MEASURE" or command[0] == "M":

            # Print help
            if len(command) == 2 and command[1].upper() == "H":
                print("\n\tMeasure I-V/IF curves (high-resolution)\n")
                print("\tUseage: MEASURE <npts> <average> <sleeptime>")
                print("\t        M <npts> <average> <sleeptime>")
                print("\twhere <npts> is the number of points (default 100)")
                print("\t      <average> is the averaging (default 32)")
                print("\t      <sleeptime> is the sleep time between points (default 0.05)\n")
                continue

            print("\n\tMEASURE I-V + IF CURVE:")

            # arg 1: number of points
            if len(command) > 1:
                npts = int(command[1])
            else:
                npts = 100

            # arg 2: averaging
            if len(command) > 2:
                average = int(command[2])
            else:
                average = 32

            # arg 3: sleep time
            if len(command) > 3:
                sleep_time = float(command[3])
            else:
                sleep_time = 0.05

            # Parameters
            vmin, vmax = param["VMIN"], param["VMAX"]
            vctrl_sweep = np.linspace(vmin, vmax, npts)
            print(f"\n\tVoltage sweep: {vmin:.1f} to {vmax:.1f} V\n")

            # Sweep bias voltage and measure voltage / current / IF power
            try:
                voltage = np.empty_like(vctrl_sweep)
                current = np.empty_like(vctrl_sweep)
                ifpower = np.empty_like(vctrl_sweep)
                for i, _vctrl in np.ndenumerate(vctrl_sweep):
                    bias.set_control_voltage(_vctrl, vmax=param['VLIMIT'])
                    time.sleep(sleep_time)
                    vtmp, itmp, ptmp = np.empty(average), np.empty(average), np.empty(average)
                    for j in range(average):
                        vtmp[j] = bias.read_voltage()  # mV
                        itmp[j] = bias.read_current()  # uA
                        ptmp[j] = bias.read_ifpower()  # A.U.
                    voltage[i] = np.mean(vtmp)
                    current[i] = np.mean(itmp)
                    ifpower[i] = np.mean(ptmp)
                    progress_bar(i[0] + 1, len(vctrl_sweep), prefix="\tProgress: ")
            except KeyboardInterrupt:
                print("")
                plt.close('all')
                continue  # TODO

            # Sort by voltage
            idx = voltage.argsort()
            voltage, current, ifpower = voltage[idx], current[idx], ifpower[idx]
            print(f"\n\tVoltage range:\t\t{voltage.min():5.1f} to {voltage.max():5.1f} mV")
            print(f"\n\tRange for linear fit:\t{param['VMIN_SLOPE']:5.1f} to {param['VMAX_SLOPE']:5.1f} mV")

            # Correct for current offset
            if -param["VMIN"] == param["VMAX"]:  # update value
                v_tmp = np.linspace(3*param['NJUNC'], voltage.max()-0.1, 101)
                current_offset = np.mean(np.interp(v_tmp, voltage, current) -
                                         np.interp(v_tmp, -voltage[::-1], -current[::-1])) / 2
                print("\n\tCurrent offset:\t\t{:.2f} uA".format(current_offset))
                current -= current_offset
                param['IOFFSET'] = current_offset
            else:  # use previous value
                current -= param['IOFFSET']

            # Correct for IF power offset
            print("\n\tMean IF power:\t\t{:.4f} uW".format(np.mean(ifpower)))
            if param['LNA'] == 'off':
                param['IFOFFSET'] = np.mean(ifpower)
            ifpower -= param['IFOFFSET']
            print("\t              \t\t{:.4f} uW (after correction)".format(np.mean(ifpower)))

            # Find intercept and normal resistance
            if param['FREQ'] == 0:
                mask = (param['VMIN_SLOPE'] <= voltage) & (voltage <= param['VMAX_SLOPE'])
                try:
                    pnormal = np.polyfit(voltage[mask], current[mask], 1)
                    v_intercept = -pnormal[1] / pnormal[0]
                    print("\n\tIntercept:\t\t{:.3f} mV".format(v_intercept))
                    rnormal = 1000 / pnormal[0]
                    print("\n\tNormal resistance:\t{:.1f} ohms".format(rnormal))
                except:
                    pnormal = None
                    pass

            # Calibrate IF power
            if param['FREQ'] == 0 and param['LNA'] == 'on':
                mask = (param['VMIN_SLOPE'] <= voltage) & (voltage <= param['VMAX_SLOPE'])
                pshot = np.polyfit(voltage[mask], ifpower[mask], 1)
                uw_to_k = 5.8 / pshot[0] / param['NJUNC']  # TODO: check
                ifpower_k = ifpower * uw_to_k
                pshot_k = np.polyfit(voltage[mask], ifpower[mask], 1)
                print(f"\n\tShot noise slope: {1/pshot_k[0]:.2f} K/mV")
                param['IFCORR'] = uw_to_k
                print(f"\n\tIF power, uW -> K:\t{uw_to_k:.2f}")
            else:
                ifpower_k = ifpower * param['IFCORR']

            # Calculate IF noise
            if param['FREQ'] == 0 and param['LNA'] == 'on':
                mask = (param['VMIN_SLOPE'] <= voltage) & (voltage <= param['VMAX_SLOPE'])
                try:
                    pifnoise = np.polyfit(voltage[mask], ifpower_k[mask], 1)
                    if_noise = np.polyval(pifnoise, v_intercept)
                    gamma = (50 - rnormal) / (50 + rnormal)
                    gmismatch = 1 - np.abs(gamma) ** 2
                    if_noise_corr = (if_noise - 1.3) * gmismatch
                    print("\n\tIF noise:\t\t{:.1f} K".format(if_noise))
                    print("\t         \t\t{:.1f} K (after correction)".format(if_noise_corr))
                    print("")
                except:
                    pass

            # Plot I-V curve
            fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12,5))
            if vmin == -vmax:
                ax1.plot(-voltage, -current, 'k-', alpha=0.5)
            if param['FREQ'] != 0:
                ax1.plot(voltage, current, 'k-', label='I-V curve')
            else:
                ax1.plot(voltage, current, 'k-', label='DC I-V curve')
                if pnormal is not None:
                    ax1.plot(voltage[voltage > 0], np.polyval(pnormal, voltage[voltage > 0]), 'r-', lw=0.5, label=r"$R_n={:.1f}~\Omega$".format(rnormal))
                if param['LNA'] == 'on':
                    try:
                        ax1.plot(v_intercept, 0, 'r*', ms=10, label="$x$-intercept")
                    except:
                        pass
            ax1.set_xlabel("Voltage (mV)")
            ax1.set_ylabel("Current (uA)")
            ax1.legend(loc=2, frameon=True)

            # Plot IF power
            if param['FREQ'] == 0 and param['LNA'] == 'on':
                ax2.plot(voltage, ifpower_k, 'k-', label='IF power')
                if vmin == -vmax:
                    ax2.plot(-voltage, ifpower_k, 'k-', alpha=0.5)
                try:
                    ax2.plot(voltage, np.polyval(pifnoise, voltage), 'r-', lw=0.5)
                    tif_str = r"$T_\mathrm{IF}$"
                    ax2.plot(v_intercept, if_noise, 'r*', ms=10, label="{}: {:.1f} K".format(tif_str, if_noise))
                    tif_str = r"$T_\mathrm{IF}^\prime$"
                    ax2.plot(v_intercept, if_noise_corr, 'b*', ms=10, label="{}: {:.1f} K".format(tif_str, if_noise_corr))
                    ax2.set_ylabel("IF Power (K)")
                except:
                    pass
            else:
                ax2.plot(voltage, ifpower, 'k-', label='IF power')
                if vmin == -vmax:
                    ax2.plot(-voltage, ifpower, 'k-', alpha=0.5)
                ax2.set_ylabel("IF Power (uW)")
            ax2.set_xlabel("Voltage (mV)")
            ax2.set_ylim(ymin=0)
            ax2.legend(loc=4, frameon=True)
            plt.show()

            filename = ask_filename()
            if filename is None:
                print("\n\tNot any saving data.\n")
            else:
                # Save data
                header = "Voltage (mV), Current (uA), IF power (K)"
                np.savetxt(filename + ".dat", np.vstack((voltage, current, ifpower_k)).T, header=header)
                # Save metadata
                with open(filename + ".mdat", "w") as fout:
                    json.dump(param, fout, indent=4)

        # MEASUREIF: Measure IF power vs IF frequency
        elif command[0] == "MEASUREIF" or command[0] == "MIF":

            # Print help
            if len(command) == 2 and command[1].upper() == "H":
                print("\n\tMeasure IF power versus IF frequency\n")
                print("\tUseage: MEASUREIF <start> <stop> <step> <average>")
                print("\t        MIF <start> <stop> <step> <average>")
                print("\twhere <start> is the start frequency, in units GHz (default 3)")
                print("\t      <stop> is the stop frequency, in units GHz (default 20)")
                print("\t      <step> is the frequency step, in units GHz (default 0.1)")
                print("\t      <average> is the number of points to average (default 100)\n")
                continue

            print("\n\tMEASURE IF POWER VS IF FREQUENCY:\n")

            # arg 1: start
            if len(command) > 1:
                start = float(command[1])
            else:
                start = 3.0

            # arg 2: stop
            if len(command) > 2:
                stop = float(command[2])
            else:
                stop = 20.0

            # arg 3: step
            if len(command) > 3:
                step = float(command[3])
            else:
                step = 0.1

            # arg 4: average
            if len(command) > 4:
                average = float(command[3])
            else:
                average = 100

            # Measure IF power
            try:
                if_frequency = np.arange(start, stop+1e-10, step)
                if_power = np.empty_like(if_frequency)
                if_power_std = np.empty_like(if_frequency)
                for i, _if_freq in np.ndenumerate(if_frequency):
                    if_filter.set_frequency(_if_freq)
                    time.sleep(0.1)
                    _ifpower_au = np.zeros(average)
                    for j in range(average):
                        _ifpower_au[j] = bias.read_ifpower()
                    if_power[i] = np.mean(_ifpower_au) - param["IFOFFSET"]
                    if_power_std[i] = np.std(_ifpower_au)
                    progress_bar(i[0] + 1, len(if_frequency), prefix="\tProgress: ")
            except KeyboardInterrupt:
                print("")
                plt.close('all')
                continue

            # Return to previous IF frequency
            if_filter.set_frequency(param['IFFREQ'])

            # Plot
            plt.figure(figsize=(6,5))
            plt.plot(if_frequency, if_power)
            plt.fill_between(if_frequency, if_power - if_power_std, if_power + if_power_std, alpha=0.2)
            plt.xlabel("IF frequency (GHZ)")
            plt.ylabel("IF power (AU)")
            plt.show()

            # Save data
            filename = ask_filename()
            if filename is None:
                print("\tNot any saving data.\n")
            else:
                # Save data
                header = "IF frequency (GHz), IF power (AU), IF std dev (AU)"
                np.savetxt(filename + ".dat", np.vstack((if_frequency, if_power, if_power_std)).T, header=header)
                # Save metadata
                with open(filename + ".mdat", "w") as fout:
                    json.dump(param, fout, indent=4)

        # CONST: Set constant bias and monitor V + I
        elif command[0] == "CONST":

            # Print help
            if len(command) == 2 and command[1].upper() == "H":
                print("\n\tSet constant control voltage and measure statistics\n")
                print("\tUseage: CONST <vcontrol> <npts>")
                print("\twhere <vcontrol> is the control voltage, in units [V]")
                print("\t      <npts> is the number of sample points (default is 50,000)\n")
                continue

            print("\n\tCONSTANT CONTROL VOLTAGE:\n")

            # arg 1: control voltage
            if len(command) > 1:
                param['VCTRL'] = float(command[1])

            # arg 2: number of sample points
            if len(command) > 2:
                npts = int(command[2])
            else:
                npts = 50_000

            # Set constant bias voltage
            bias.set_control_voltage(param['VCTRL'], vmax=param['VLIMIT'])
            time.sleep(1.5)
            vmon = bias.read_voltage()
            imon = bias.read_current() - param['IOFFSET']
            print(f"\tControl voltage: {param['VCTRL']:.1f} V")
            print(f"\tVoltage monitor: {vmon:.1f} mV")
            print(f"\tCurrent monitor: {imon:.1f} uA\n")

            # Sample voltage/current monitors
            try:
                voltage = np.empty(npts)
                current = np.empty(npts)
                ifpower = np.empty(npts)
                start = time.time()
                for i in range(npts):
                    voltage[i] = bias.read_voltage()
                    current[i] = bias.read_current()
                    ifpower[i] = bias.read_ifpower()
                    if i % 1000 == 0 or i + 1 == npts:
                        progress_bar(i + 1, npts, prefix="\tProgress: ")
                current -= param['IOFFSET']
                ifpower -= param['IFOFFSET']
                total_time = time.time() - start
                t = np.linspace(0, total_time, npts)
                ifpower *= 10
            except KeyboardInterrupt:
                print("")
                plt.close('all')
                continue

            # Print statistics
            print("\n\tVoltage monitor:")
            print("\t\tMean:               {:7.3f} mV".format(np.mean(voltage)))
            print("\t\tStandard deviation: {:7.3f} uV".format(np.std(voltage)))
            print("\t\t                    {:7.1f} % ".format(np.std(voltage)/np.mean(voltage)*100))
            print("\tCurrent monitor:")
            print("\t\tMean:               {:7.2f} uA".format(np.mean(current)))
            print("\t\tStandard deviation: {:7.2f} uA".format(np.std(current)))
            print("\t\t                    {:7.1f} % ".format(np.std(current)/np.mean(current)*100))
            print("\tIF power:")
            print("\t\tMean:               {:7.3f} au".format(np.mean(ifpower)))
            print("\t\tStandard deviation: {:7.3f} au".format(np.std(ifpower)))
            print("\t\t                    {:7.1f} % ".format(np.std(ifpower)/np.mean(ifpower)*100))
            print("\n\tSampling frequency: {:.1f} kHz".format(npts*2/total_time/1e3))
            print("\n\tTotal time:         {:.1f} s\n".format(total_time))

            # Plot
            fig, ((ax1, ax3, ax5), (ax2, ax4, ax6)) = plt.subplots(2, 3, figsize=(15, 8))
            ax1.plot(t, voltage, 'k', lw=0.5, alpha=0.2)
            ax1.plot(t, gauss_conv(voltage, 3), 'r')
            ax1.axhspan(-np.std(voltage)+np.mean(voltage), np.std(voltage)+np.mean(voltage), color='r', alpha=0.2)
            ax3.plot(t, current, 'k', lw=0.5, alpha=0.2)
            ax3.plot(t, gauss_conv(current, 3), 'r')
            ax3.axhspan(-np.std(current)+np.mean(current), np.std(current)+np.mean(current), color='r', alpha=0.2)
            ax5.plot(t, ifpower, 'k', lw=0.5, alpha=0.2)
            ax5.plot(t, gauss_conv(ifpower, 3), 'r')
            ax5.axhspan(-np.std(ifpower)+np.mean(ifpower), np.std(ifpower)+np.mean(ifpower), color='r', alpha=0.2)

            # Zero
            voltage -= np.mean(voltage)
            current -= np.mean(current)
            ifpower -= np.mean(ifpower)

            # FFT
            voltage_fft = np.fft.fftshift(np.fft.fft(voltage))
            current_fft = np.fft.fftshift(np.fft.fft(current))
            ifpower_fft = np.fft.fftshift(np.fft.fft(ifpower))
            f = np.fft.fftshift(np.fft.fftfreq(len(voltage), d=t[1]-t[0]))

            # Peak values
            idx = np.abs(voltage_fft).argmax()
            print(f"\tPeak voltage:  {np.abs(voltage_fft[idx]):7.1f} at {abs(f[idx]):4.1f} Hz")
            idx = np.abs(current_fft).argmax()
            print(f"\tPeak current:  {np.abs(current_fft[idx]):7.1f} at {abs(f[idx]):4.1f} Hz")
            idx = np.abs(ifpower_fft).argmax()
            print(f"\tPeak IF power: {np.abs(ifpower_fft[idx]):7.1f} at {abs(f[idx]):4.1f} Hz")
            print("")

            # Plot
            ax2.plot(f, np.abs(voltage_fft), 'k', lw=0.5, alpha=0.2)
            ax2.plot(f, gauss_conv(np.abs(voltage_fft), 3), 'r', lw=2)
            ax2.axvspan(55, 65, color='r', alpha=0.2)
            ax4.plot(f, np.abs(current_fft), 'k', lw=0.5, alpha=0.2)
            ax4.plot(f, gauss_conv(np.abs(current_fft), 3), 'r', lw=2)
            ax4.axvspan(55, 65, color='r', alpha=0.2)
            ax6.plot(f, np.abs(ifpower_fft), 'k', lw=0.5, alpha=0.5)
            ax6.plot(f, gauss_conv(np.abs(ifpower_fft), 1), 'r', lw=2)
            ax6.axvspan(1.1, 1.3, color='r', alpha=0.2)
            ax1.set_xlabel("Time (s)")
            ax3.set_xlabel("Time (s)")
            ax5.set_xlabel("Time (s)")
            ax1.set_ylabel("Voltage (mV)")
            ax3.set_ylabel("Current (uA)")
            ax5.set_ylabel("IF Power (au)")
            ax2.set_xlabel("Frequency (Hz)")
            ax4.set_xlabel("Frequency (Hz)")
            ax6.set_xlabel("Frequency (Hz)")
            ax2.set_ylabel("Voltage")
            ax4.set_ylabel("Current")
            ax6.set_ylabel("IF Power")
            ax1.set_xlim([0, t.max()])
            ax3.set_xlim([0, t.max()])
            ax5.set_xlim([0, t.max()])
            ax2.set_xlim([0, 500])
            ax4.set_xlim([0, 500])
            ax6.set_xlim([-1, 5])
            ax2.set_ylim(ymin=0)
            ax4.set_ylim(ymin=0)
            ax6.set_ylim(ymin=0)
            plt.show()

        # RESISTANCE: Fit resistance of I-V curve
        elif command[0] == "RESISTANCE" or command[0] == "R":

            # Print help
            if len(command) == 2 and command[1].upper() == "H":
                print("\n\tMeasure the resistance of the I-V curve\n")
                print("\tUseage: RESISTANCE")
                print("\t        R\n")
                continue

            voltage, current, _ = bias.read_iv_curve()
            idx = current.argsort()
            p, cov = np.polyfit(current[idx], voltage[idx], 1, cov=True)
            perr = np.sqrt(np.diag(cov))
            print(f"\n\tResistance: {p[0]:.2f} +/- {perr[0]:.2f} ohms\n")

        # Digital input/output --------------------------------------------- #

        # HOT: move load to hot position
        elif command[0] == "HOT":

            # Print help
            if len(command) == 2 and command[1].upper() == "H":
                print("\n\tSet load to hot position\n")
                print("\tUseage: HOT\n")
                continue

            bias.hot_load()

        # COLD: move load to cold position
        elif command[0] == "COLD":

            # Print help
            if len(command) == 2 and command[1].upper() == "H":
                print("\n\tSet load to cold position\n")
                print("\tUseage: COLD\n")
                continue

            bias.cold_load()

        # Misc functions --------------------------------------------------- #

        # HELP: Print help for most useful commands
        elif command[0] == "HELP" or command[0] == "H":

            print("\n\tMost useful commands/parameters:\n")
            print("\tVMIN <value>:\tMinimum voltage for sweep, in units [V]")
            print("\tVMAX <value>:\tMaximum voltage for sweep, in units [V]\n")
            print("\tV <value>:   \tSet control voltage to constant value, units [V]")
            print("\tVB <value>:  \tSet bias voltage to constant value, units [mV]\n")
            print("\tVMON:        \tRead the voltage monitor")
            print("\tIMON:        \tRead the current monitor")
            print("\tPIF:         \tRead the IF power\n")
            print("\tM:           \tMeasure IV/IF curves")
            print("\tMIF:         \tMeasure power versus IF frequency")
            print("\tMON:         \tPlot IV/IF curves in real-time\n")
            print("\tC:           \tClear all plots")
            print("\tQ:           \tExit application\n")
            print("\tFor all of these commands, you can enter 'H' for more help")
            print("\t(e.g., 'M H').\n")

        # ID: Print DAQ ID nubmer
        elif command[0] == "ID":

            # Print help
            if len(command) == 2 and command[1].upper() == "H":
                print("\n\tPrint ID of DAQ unit\n")
                print("\tUseage: ID\n")
                continue

            print("\n\t", bias, "\n")

        # INFO: Print all parameters
        elif command[0] == "INFO":

            # Print help
            if len(command) == 2 and command[1].upper() == "H":
                print("\n\tPrint all parameters\n")
                print("\tUseage: INFO\n")
                continue

            print("")
            for key, value in param.items():
                if isinstance(value, int) or isinstance(value, float):
                    print(f"\t{key:15s}{value:.1f}")
                else:
                    print(f"\t{key:15s}{value}")
            print("")

        # CLEAR: Clear all plots
        elif command[0] == "CLEAR" or command[0] == "C":

            # Print help
            if len(command) == 2 and command[1].upper() == "H":
                print("\n\tClear all plots\n")
                print("\tUseage: CLEAR")
                print("\t        C\n")
                continue

            plt.close("all")

        # EXIT: Stop bias and shutdown
        elif command[0] == "EXIT" or command[0] == "Q":

            # Print help
            if len(command) == 2 and command[1].upper() == "H":
                print("\n\tStop bias and shutdown\n")
                print("\tUseage: EXIT")
                print("\t        Q\n")
                continue

            break

        # Command not recognized...
        else:
            print("\n\tCommand not recognized.\n")

except KeyboardInterrupt:
    print("\nClosing program.")

except EOFError:
    print("\nClosing program.")

finally:
    # Save parameters to file (for persistence)
    with open(param_filename, 'w') as fout:
        json.dump(param, fout, indent=4)
    print(f"\nParameters saved to: {param_filename}")
    try:
        # Set bias voltage to zero
        bias.set_control_voltage(0, verbose=True)
        # Close connection
        bias.close()
    except NameError:
        pass
